/**
 * Python Code Generator
 * Generates Python client code for AI models
 */

import { CodeGenerator } from './CodeGenerator.js';

export class PythonGenerator extends CodeGenerator {
  /**
   * Generate Python code
   */
  generatePython(models, options) {
    const { style } = options;
    
    if (style === 'class') {
      return this.generateClassStyle(models);
    } else if (style === 'dataclass') {
      return this.generateDataclassStyle(models);
    } else if (style === 'enum') {
      return this.generateEnumStyle(models);
    } else {
      return this.generateDictStyle(models);
    }
  }

  /**
   * Generate class-based style
   */
  generateClassStyle(models) {
    const grouped = this.groupByProvider(models);
    
    let code = `"""
AI Model Client SDK
Generated by KHAOS-Researcher on ${this.getTimestamp()}
Total models: ${Object.keys(models).length}
"""

from typing import List, Dict, Optional, Any


class Model:
    """Base model class"""
    def __init__(self, id: str, provider: str, capabilities: List[str], 
                 metadata: Optional[Dict[str, str]] = None, created: Optional[int] = None):
        self.id = id
        self.provider = provider
        self.capabilities = capabilities
        self.metadata = metadata or {}
        self.created = created
    
    def has_capability(self, capability: str) -> bool:
        """Check if model has a specific capability"""
        return capability in self.capabilities
    
    def __repr__(self):
        return f"Model(id='{self.id}', provider='{self.provider}')"


`;

    // Generate provider classes
    for (const [provider, providerModels] of Object.entries(grouped)) {
      code += `class ${provider}Models:\n`;
      code += `    """${provider} AI Models"""\n`;
      
      // Add class attributes for each model
      for (const model of providerModels) {
        const identifier = this.formatPythonIdentifier(model.id);
        code += `    ${identifier} = Model(\n`;
        code += `        id="${model.id}",\n`;
        code += `        provider="${model.provider}",\n`;
        code += `        capabilities=[${model.capabilities?.map(c => `"${c}"`).join(', ') || ''}],\n`;
        
        if (model.metadata && Object.keys(model.metadata).length > 0) {
          code += `        metadata={\n`;
          for (const [key, value] of Object.entries(model.metadata)) {
            code += `            "${key}": "${value}",\n`;
          }
          code += `        },\n`;
        }
        
        code += `        created=${model.created || 'None'}\n`;
        code += `    )\n\n`;
      }

      // Add helper methods
      code += `    @classmethod\n`;
      code += `    def get_all(cls) -> List[Model]:\n`;
      code += `        """Get all ${provider} models"""\n`;
      code += `        return [\n`;
      for (const model of providerModels) {
        code += `            cls.${this.formatPythonIdentifier(model.id)},\n`;
      }
      code += `        ]\n\n`;

      code += `    @classmethod\n`;
      code += `    def get_by_id(cls, model_id: str) -> Optional[Model]:\n`;
      code += `        """Get model by ID"""\n`;
      code += `        for model in cls.get_all():\n`;
      code += `            if model.id == model_id:\n`;
      code += `                return model\n`;
      code += `        return None\n\n`;

      code += `    @classmethod\n`;
      code += `    def get_by_capability(cls, capability: str) -> List[Model]:\n`;
      code += `        """Get models with specific capability"""\n`;
      code += `        return [m for m in cls.get_all() if m.has_capability(capability)]\n\n\n`;
    }

    // Add main Models class
    code += `class Models:\n`;
    code += `    """Main interface for all AI models"""\n`;
    for (const provider of Object.keys(grouped)) {
      code += `    ${provider} = ${provider}Models\n`;
    }
    
    code += `\n    @staticmethod\n`;
    code += `    def get_all_models() -> List[Model]:\n`;
    code += `        """Get all models from all providers"""\n`;
    code += `        models = []\n`;
    for (const provider of Object.keys(grouped)) {
      code += `        models.extend(${provider}Models.get_all())\n`;
    }
    code += `        return models\n\n`;

    code += `    @staticmethod\n`;
    code += `    def find_model(model_id: str) -> Optional[Model]:\n`;
    code += `        """Find a model by ID across all providers"""\n`;
    code += `        for model in Models.get_all_models():\n`;
    code += `            if model.id == model_id:\n`;
    code += `                return model\n`;
    code += `        return None\n\n`;

    code += `    @staticmethod\n`;
    code += `    def get_providers() -> List[str]:\n`;
    code += `        """Get all available providers"""\n`;
    code += `        return [${Object.keys(grouped).map(p => `"${p}"`).join(', ')}]\n`;

    return code;
  }

  /**
   * Generate dataclass style
   */
  generateDataclassStyle(models) {
    const grouped = this.groupByProvider(models);
    
    let code = `"""
AI Model Client SDK (Dataclass Style)
Generated by KHAOS-Researcher on ${this.getTimestamp()}
Total models: ${Object.keys(models).length}
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional
from enum import Enum


@dataclass(frozen=True)
class Model:
    """AI Model dataclass"""
    id: str
    provider: str
    capabilities: List[str] = field(default_factory=list)
    metadata: Dict[str, str] = field(default_factory=dict)
    created: Optional[int] = None
    
    def has_capability(self, capability: str) -> bool:
        """Check if model has a specific capability"""
        return capability in self.capabilities


# Model definitions
`;

    // Generate model constants
    for (const [key, model] of Object.entries(models)) {
      const identifier = this.formatPythonIdentifier(model.id);
      code += `${identifier} = Model(\n`;
      code += `    id="${model.id}",\n`;
      code += `    provider="${model.provider}",\n`;
      code += `    capabilities=[${model.capabilities?.map(c => `"${c}"`).join(', ') || ''}],\n`;
      
      if (model.metadata && Object.keys(model.metadata).length > 0) {
        code += `    metadata={\n`;
        for (const [k, v] of Object.entries(model.metadata)) {
          code += `        "${k}": "${v}",\n`;
        }
        code += `    },\n`;
      }
      
      code += `    created=${model.created || 'None'}\n`;
      code += `)\n\n`;
    }

    // Generate provider groups
    code += `# Provider model groups\n`;
    for (const [provider, providerModels] of Object.entries(grouped)) {
      code += `${provider.toUpperCase()}_MODELS = [\n`;
      for (const model of providerModels) {
        code += `    ${this.formatPythonIdentifier(model.id)},\n`;
      }
      code += `]\n\n`;
    }

    // Generate helper functions
    code += `# Helper functions\n`;
    code += `def get_all_models() -> List[Model]:\n`;
    code += `    """Get all available models"""\n`;
    code += `    return [\n`;
    for (const model of Object.values(models)) {
      code += `        ${this.formatPythonIdentifier(model.id)},\n`;
    }
    code += `    ]\n\n`;

    code += `def get_model_by_id(model_id: str) -> Optional[Model]:\n`;
    code += `    """Find model by ID"""\n`;
    code += `    for model in get_all_models():\n`;
    code += `        if model.id == model_id:\n`;
    code += `            return model\n`;
    code += `    return None\n\n`;

    code += `def get_models_by_capability(capability: str) -> List[Model]:\n`;
    code += `    """Get models with specific capability"""\n`;
    code += `    return [m for m in get_all_models() if m.has_capability(capability)]\n`;

    return code;
  }

  /**
   * Generate enum style
   */
  generateEnumStyle(models) {
    let code = `"""
AI Model Enums
Generated by KHAOS-Researcher on ${this.getTimestamp()}
Total models: ${Object.keys(models).length}
"""

from enum import Enum, auto
from typing import List, Dict, Optional


`;

    // Generate model ID enum
    code += `class ModelID(str, Enum):\n`;
    code += `    """Enumeration of all model IDs"""\n`;
    for (const model of Object.values(models)) {
      const identifier = this.formatPythonIdentifier(model.id);
      code += `    ${identifier} = "${model.id}"\n`;
    }
    code += `\n\n`;

    // Generate provider enum
    const providers = [...new Set(Object.values(models).map(m => m.provider))];
    code += `class Provider(str, Enum):\n`;
    code += `    """Enumeration of all providers"""\n`;
    for (const provider of providers) {
      code += `    ${provider.toUpperCase()} = "${provider}"\n`;
    }
    code += `\n\n`;

    // Generate capability enum
    const capabilities = new Set();
    for (const model of Object.values(models)) {
      if (model.capabilities) {
        model.capabilities.forEach(cap => capabilities.add(cap));
      }
    }
    
    code += `class Capability(str, Enum):\n`;
    code += `    """Enumeration of all capabilities"""\n`;
    for (const capability of capabilities) {
      code += `    ${this.formatPythonIdentifier(capability)} = "${capability}"\n`;
    }
    code += `\n\n`;

    // Generate model info mapping
    code += `# Model information mapping\n`;
    code += `MODEL_INFO: Dict[ModelID, Dict[str, any]] = {\n`;
    for (const model of Object.values(models)) {
      const identifier = this.formatPythonIdentifier(model.id);
      code += `    ModelID.${identifier}: {\n`;
      code += `        "provider": Provider.${model.provider.toUpperCase()},\n`;
      code += `        "capabilities": [${model.capabilities?.map(c => {
        const capId = this.formatPythonIdentifier(c);
        return `Capability.${capId}`;
      }).join(', ') || ''}],\n`;
      
      if (model.metadata && Object.keys(model.metadata).length > 0) {
        code += `        "metadata": {\n`;
        for (const [k, v] of Object.entries(model.metadata)) {
          code += `            "${k}": "${v}",\n`;
        }
        code += `        },\n`;
      }
      
      code += `        "created": ${model.created || 'None'},\n`;
      code += `    },\n`;
    }
    code += `}\n\n`;

    // Helper functions
    code += `def get_model_info(model_id: ModelID) -> Dict[str, any]:\n`;
    code += `    """Get model information by ID"""\n`;
    code += `    return MODEL_INFO.get(model_id, {})\n\n`;

    code += `def get_models_by_provider(provider: Provider) -> List[ModelID]:\n`;
    code += `    """Get all models from a provider"""\n`;
    code += `    return [mid for mid, info in MODEL_INFO.items() if info["provider"] == provider]\n\n`;

    code += `def get_models_by_capability(capability: Capability) -> List[ModelID]:\n`;
    code += `    """Get models with specific capability"""\n`;
    code += `    return [mid for mid, info in MODEL_INFO.items() if capability in info["capabilities"]]\n`;

    return code;
  }

  /**
   * Generate dictionary style
   */
  generateDictStyle(models) {
    const grouped = this.groupByProvider(models);
    
    let code = `"""
AI Model Dictionary
Generated by KHAOS-Researcher on ${this.getTimestamp()}
Total models: ${Object.keys(models).length}
"""

from typing import List, Dict, Optional, Any


# AI Models organized by provider
AI_MODELS = {\n`;
    
    for (const [provider, providerModels] of Object.entries(grouped)) {
      code += `    "${provider}": {\n`;
      
      for (const model of providerModels) {
        code += `        "${model.id}": {\n`;
        code += `            "id": "${model.id}",\n`;
        code += `            "provider": "${model.provider}",\n`;
        code += `            "capabilities": [${model.capabilities?.map(c => `"${c}"`).join(', ') || ''}],\n`;
        
        if (model.metadata && Object.keys(model.metadata).length > 0) {
          code += `            "metadata": {\n`;
          for (const [key, value] of Object.entries(model.metadata)) {
            code += `                "${key}": "${value}",\n`;
          }
          code += `            },\n`;
        }
        
        code += `            "created": ${model.created || 'None'},\n`;
        code += `        },\n`;
      }
      
      code += `    },\n`;
    }
    
    code += `}\n\n`;

    // Add helper functions
    code += `def get_model(provider: str, model_id: str) -> Optional[Dict[str, Any]]:\n`;
    code += `    """Get model by provider and ID"""\n`;
    code += `    return AI_MODELS.get(provider, {}).get(model_id)\n\n`;

    code += `def get_all_models() -> List[Dict[str, Any]]:\n`;
    code += `    """Get all models as a flat list"""\n`;
    code += `    models = []\n`;
    code += `    for provider_models in AI_MODELS.values():\n`;
    code += `        models.extend(provider_models.values())\n`;
    code += `    return models\n\n`;

    code += `def get_models_by_provider(provider: str) -> List[Dict[str, Any]]:\n`;
    code += `    """Get all models from a specific provider"""\n`;
    code += `    return list(AI_MODELS.get(provider, {}).values())\n\n`;

    code += `def get_models_by_capability(capability: str) -> List[Dict[str, Any]]:\n`;
    code += `    """Get all models with a specific capability"""\n`;
    code += `    matching_models = []\n`;
    code += `    for model in get_all_models():\n`;
    code += `        if capability in model.get("capabilities", []):\n`;
    code += `            matching_models.append(model)\n`;
    code += `    return matching_models\n\n`;

    code += `def get_providers() -> List[str]:\n`;
    code += `    """Get all available providers"""\n`;
    code += `    return list(AI_MODELS.keys())\n`;

    return code;
  }

  /**
   * Format Python identifier
   */
  formatPythonIdentifier(name) {
    return name
      .replace(/[^a-zA-Z0-9]/g, '_')
      .replace(/^(\d)/, '_$1')
      .toUpperCase();
  }
}