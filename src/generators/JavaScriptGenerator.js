/**
 * JavaScript/TypeScript Code Generator
 * Generates JS/TS client code for AI models
 */

import { CodeGenerator } from './CodeGenerator.js';

export class JavaScriptGenerator extends CodeGenerator {
  /**
   * Generate JavaScript code
   */
  generateJavaScript(models, options) {
    const { style, includeTypes } = options;
    
    if (style === 'class') {
      return this.generateClassStyle(models, 'javascript', includeTypes);
    } else if (style === 'object') {
      return this.generateObjectStyle(models, 'javascript', includeTypes);
    } else {
      return this.generateConstantsStyle(models, 'javascript', includeTypes);
    }
  }

  /**
   * Generate TypeScript code
   */
  generateTypeScript(models, options) {
    const { style } = options;
    
    if (style === 'class') {
      return this.generateClassStyle(models, 'typescript', true);
    } else if (style === 'object') {
      return this.generateObjectStyle(models, 'typescript', true);
    } else {
      return this.generateConstantsStyle(models, 'typescript', true);
    }
  }

  /**
   * Generate class-based style
   */
  generateClassStyle(models, language, includeTypes) {
    const isTypeScript = language === 'typescript';
    const grouped = this.groupByProvider(models);
    
    let code = `/**
 * AI Model Client SDK
 * Generated by KHAOS-Researcher on ${this.getTimestamp()}
 * Total models: ${Object.keys(models).length}
 */

`;

    // Add TypeScript interfaces
    if (isTypeScript) {
      code += this.generateTypeScriptInterfaces();
    }

    // Generate provider classes
    for (const [provider, providerModels] of Object.entries(grouped)) {
      code += `export class ${provider}Models {\n`;
      
      // Add static properties for each model
      for (const model of providerModels) {
        const identifier = this.formatIdentifier(model.id);
        code += `  static ${identifier}${isTypeScript ? ': Model' : ''} = {\n`;
        code += `    id: "${model.id}",\n`;
        code += `    provider: "${model.provider}",\n`;
        code += `    capabilities: [${model.capabilities?.map(c => `"${c}"`).join(', ') || ''}],\n`;
        
        if (model.metadata) {
          code += `    metadata: {\n`;
          for (const [key, value] of Object.entries(model.metadata)) {
            code += `      ${key}: "${value}",\n`;
          }
          code += `    },\n`;
        }
        
        code += `    created: ${model.created || 'null'},\n`;
        code += `  };\n\n`;
      }

      // Add helper methods
      code += `  static getAll()${isTypeScript ? ': Model[]' : ''} {\n`;
      code += `    return [\n`;
      for (const model of providerModels) {
        code += `      this.${this.formatIdentifier(model.id)},\n`;
      }
      code += `    ];\n`;
      code += `  }\n\n`;

      code += `  static getById(id${isTypeScript ? ': string' : ''})${isTypeScript ? ': Model | undefined' : ''} {\n`;
      code += `    return this.getAll().find(model => model.id === id);\n`;
      code += `  }\n\n`;

      code += `  static getByCapability(capability${isTypeScript ? ': string' : ''})${isTypeScript ? ': Model[]' : ''} {\n`;
      code += `    return this.getAll().filter(model => \n`;
      code += `      model.capabilities.includes(capability)\n`;
      code += `    );\n`;
      code += `  }\n`;

      code += `}\n\n`;
    }

    // Add main Models class
    code += `export class Models {\n`;
    for (const provider of Object.keys(grouped)) {
      code += `  static ${provider} = ${provider}Models;\n`;
    }
    
    code += `\n  static getAllModels()${isTypeScript ? ': Model[]' : ''} {\n`;
    code += `    return [\n`;
    for (const provider of Object.keys(grouped)) {
      code += `      ...${provider}Models.getAll(),\n`;
    }
    code += `    ];\n`;
    code += `  }\n\n`;

    code += `  static findModel(id${isTypeScript ? ': string' : ''})${isTypeScript ? ': Model | undefined' : ''} {\n`;
    code += `    return this.getAllModels().find(model => model.id === id);\n`;
    code += `  }\n\n`;

    code += `  static getProviders()${isTypeScript ? ': string[]' : ''} {\n`;
    code += `    return [${Object.keys(grouped).map(p => `"${p}"`).join(', ')}];\n`;
    code += `  }\n`;
    code += `}\n`;

    return code;
  }

  /**
   * Generate object-based style
   */
  generateObjectStyle(models, language, includeTypes) {
    const isTypeScript = language === 'typescript';
    const grouped = this.groupByProvider(models);
    
    let code = `/**
 * AI Model Client SDK
 * Generated by KHAOS-Researcher on ${this.getTimestamp()}
 * Total models: ${Object.keys(models).length}
 */

`;

    if (isTypeScript) {
      code += this.generateTypeScriptInterfaces();
    }

    code += `export const AI_MODELS${isTypeScript ? ': { [provider: string]: { [modelId: string]: Model } }' : ''} = {\n`;
    
    for (const [provider, providerModels] of Object.entries(grouped)) {
      code += `  ${provider}: {\n`;
      
      for (const model of providerModels) {
        const identifier = this.formatIdentifier(model.id);
        code += `    ${identifier}: {\n`;
        code += `      id: "${model.id}",\n`;
        code += `      provider: "${model.provider}",\n`;
        code += `      capabilities: [${model.capabilities?.map(c => `"${c}"`).join(', ') || ''}],\n`;
        
        if (model.metadata) {
          code += `      metadata: {\n`;
          for (const [key, value] of Object.entries(model.metadata)) {
            code += `        ${key}: "${value}",\n`;
          }
          code += `      },\n`;
        }
        
        code += `      created: ${model.created || 'null'},\n`;
        code += `    },\n`;
      }
      
      code += `  },\n`;
    }
    
    code += `};\n\n`;

    // Add helper functions
    code += `export function getModel(provider${isTypeScript ? ': string' : ''}, modelId${isTypeScript ? ': string' : ''})${isTypeScript ? ': Model | undefined' : ''} {\n`;
    code += `  return AI_MODELS[provider]?.[modelId.replace(/[^a-zA-Z0-9]/g, '_').replace(/^(\\d)/, '_$1').toUpperCase()];\n`;
    code += `}\n\n`;

    code += `export function getAllModels()${isTypeScript ? ': Model[]' : ''} {\n`;
    code += `  const models${isTypeScript ? ': Model[]' : ''} = [];\n`;
    code += `  for (const provider of Object.values(AI_MODELS)) {\n`;
    code += `    models.push(...Object.values(provider));\n`;
    code += `  }\n`;
    code += `  return models;\n`;
    code += `}\n\n`;

    code += `export function getModelsByProvider(provider${isTypeScript ? ': string' : ''})${isTypeScript ? ': Model[]' : ''} {\n`;
    code += `  return Object.values(AI_MODELS[provider] || {});\n`;
    code += `}\n\n`;

    code += `export function getModelsByCapability(capability${isTypeScript ? ': string' : ''})${isTypeScript ? ': Model[]' : ''} {\n`;
    code += `  return getAllModels().filter(model => \n`;
    code += `    model.capabilities.includes(capability)\n`;
    code += `  );\n`;
    code += `}\n`;

    return code;
  }

  /**
   * Generate constants style
   */
  generateConstantsStyle(models, language, includeTypes) {
    const isTypeScript = language === 'typescript';
    
    let code = `/**
 * AI Model Constants
 * Generated by KHAOS-Researcher on ${this.getTimestamp()}
 * Total models: ${Object.keys(models).length}
 */

`;

    if (isTypeScript) {
      code += `export type ModelId = \n`;
      for (const model of Object.values(models)) {
        code += `  | "${model.id}"\n`;
      }
      code += `;\n\n`;

      code += `export type Provider = \n`;
      const providers = [...new Set(Object.values(models).map(m => m.provider))];
      for (const provider of providers) {
        code += `  | "${provider}"\n`;
      }
      code += `;\n\n`;
    }

    // Generate model constants
    for (const [key, model] of Object.entries(models)) {
      const identifier = this.formatIdentifier(model.id);
      code += `export const ${identifier} = "${model.id}"${isTypeScript ? ' as const' : ''};\n`;
    }
    code += '\n';

    // Generate provider groups
    const grouped = this.groupByProvider(models);
    for (const [provider, providerModels] of Object.entries(grouped)) {
      code += `export const ${provider.toUpperCase()}_MODELS = [\n`;
      for (const model of providerModels) {
        code += `  ${this.formatIdentifier(model.id)},\n`;
      }
      code += `]${isTypeScript ? ' as const' : ''};\n\n`;
    }

    // Generate capability maps
    const capabilities = new Set();
    for (const model of Object.values(models)) {
      if (model.capabilities) {
        model.capabilities.forEach(cap => capabilities.add(cap));
      }
    }

    code += `export const MODEL_CAPABILITIES${isTypeScript ? ': { [modelId: string]: string[] }' : ''} = {\n`;
    for (const model of Object.values(models)) {
      code += `  [${this.formatIdentifier(model.id)}]: [${model.capabilities?.map(c => `"${c}"`).join(', ') || ''}],\n`;
    }
    code += `};\n\n`;

    code += `export const ALL_CAPABILITIES = [${[...capabilities].map(c => `"${c}"`).join(', ')}]${isTypeScript ? ' as const' : ''};\n`;

    return code;
  }

  /**
   * Generate TypeScript interfaces
   */
  generateTypeScriptInterfaces() {
    return `export interface Model {
  id: string;
  provider: string;
  capabilities: string[];
  metadata?: {
    [key: string]: string;
  };
  created: number | null;
}

export interface ModelMetadata {
  owned_by?: string;
  family?: string;
  tier?: string;
  [key: string]: string | undefined;
}

`;
  }
}