<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KHAOS AI Model Intelligence Dashboard</title>

    <!-- Favicon links -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">

    <!-- COTOAGA.AI Typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700;900&family=Space+Grotesk:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <link rel="stylesheet" href="style.css?v=2.0">
    
    <!-- BACKUP: Inline CSS to ensure tags always work -->
    <style>
        .capability-tag {
            display: inline-block !important;
            padding: 6px 12px !important;
            margin: 3px !important;
            border-radius: 15px !important;
            font-size: 0.8em !important;
            font-weight: 700 !important;
            text-transform: lowercase !important;
            white-space: nowrap !important;
            border: 2px solid #333 !important;
            background: #FF6B6B !important;
            color: white !important;
            min-height: 20px !important;
            min-width: 40px !important;
            text-align: center !important;
        }
        
        /* Multi-color capability tags */
        span.capability-tag.text-generation { background: linear-gradient(135deg, #E3F2FD, #BBDEFB) !important; color: #1976D2 !important; border-color: #2196F3 !important; }
        span.capability-tag.community, span.capability-tag.community-hosted { background: linear-gradient(135deg, #E8F5E8, #C8E6C9) !important; color: #388E3C !important; border-color: #4CAF50 !important; }
        span.capability-tag.reasoning { background: linear-gradient(135deg, #FFF3E0, #FFE0B2) !important; color: #F57C00 !important; border-color: #FF9800 !important; }
        span.capability-tag.enterprise { background: linear-gradient(135deg, #F1F8E9, #DCEDC8) !important; color: #558B2F !important; border-color: #689F38 !important; }
        span.capability-tag.open-source { background: linear-gradient(135deg, #E0F2F1, #B2DFDB) !important; color: #00695C !important; border-color: #009688 !important; }
        span.capability-tag.image-generation { background: linear-gradient(135deg, #FCE4EC, #F8BBD9) !important; color: #C2185B !important; border-color: #E91E63 !important; }
        span.capability-tag.image-classification { background: linear-gradient(135deg, #F3E5F5, #E1BEE7) !important; color: #7B1FA2 !important; border-color: #9C27B0 !important; }
        span.capability-tag.democratized-ai { background: linear-gradient(135deg, #FFF8E1, #FFECB3) !important; color: #FF8F00 !important; border-color: #FFC107 !important; }
        span.capability-tag.code { background: linear-gradient(135deg, #F3E5F5, #E1BEE7) !important; color: #7B1FA2 !important; border-color: #9C27B0 !important; }
        span.capability-tag.vision { background: linear-gradient(135deg, #E0F2F1, #B2DFDB) !important; color: #00695C !important; border-color: #009688 !important; }
        span.capability-tag.audio { background: linear-gradient(135deg, #FCE4EC, #F8BBD9) !important; color: #C2185B !important; border-color: #E91E63 !important; }
        span.capability-tag.multimodal { background: linear-gradient(135deg, #FFF8E1, #FFECB3) !important; color: #FF8F00 !important; border-color: #FFC107 !important; }
    </style>
</head>
<body>
    <!-- Main Header -->
    <div class="header">
        <div style="display: flex; align-items: center;">
            <!-- Perfectly Aligned Chaos Star -->
            <div class="chaos-logo" style="margin-right: 15px; display: inline-block;">
                <svg width="32" height="32" viewBox="0 0 32 32" class="chaos-star-svg">
                    <!-- Gradient definition -->
                    <defs>
                        <radialGradient id="hubGradient" cx="50%" cy="30%" r="70%">
                            <stop offset="0%" style="stop-color:#6EC1E4;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#1565C0;stop-opacity:1" />
                        </radialGradient>
                    </defs>
                    
                    <!-- 8 perfectly aligned arrows -->
                    
                    <!-- Arrow 1: Up (0¬∞) -->
                    <g class="arrow-up">
                        <line x1="16" y1="16" x2="16" y2="3" stroke="#2F6EBA" stroke-width="2.5"/>
                        <polygon points="16,1 13,6 19,6" fill="#2F6EBA"/>
                        <polygon points="16,19 13,14 19,14" fill="#2F6EBA"/>
                    </g>
                    
                    <!-- Arrow 2: Up-Right (45¬∞) -->
                    <g class="arrow-up-right">
                        <line x1="16" y1="16" x2="25.2" y2="6.8" stroke="#2F6EBA" stroke-width="2.5"/>
                        <polygon points="27.1,4.9 21.4,7.6 23.8,12.2" fill="#2F6EBA"/>
                        <polygon points="17.8,17.8 12.2,15.4 14.9,20.1" fill="#2F6EBA"/>
                    </g>
                    
                    <!-- Arrow 3: Right (90¬∞) -->
                    <g class="arrow-right">
                        <line x1="16" y1="16" x2="29" y2="16" stroke="#2F6EBA" stroke-width="2.5"/>
                        <polygon points="31,16 26,13 26,19" fill="#2F6EBA"/>
                        <polygon points="13,16 18,13 18,19" fill="#2F6EBA"/>
                    </g>
                    
                    <!-- Arrow 4: Down-Right (135¬∞) -->
                    <g class="arrow-down-right">
                        <line x1="16" y1="16" x2="25.2" y2="25.2" stroke="#2F6EBA" stroke-width="2.5"/>
                        <polygon points="27.1,27.1 23.8,19.8 21.4,24.4" fill="#2F6EBA"/>
                        <polygon points="17.8,14.2 14.9,11.9 12.2,16.6" fill="#2F6EBA"/>
                    </g>
                    
                    <!-- Arrow 5: Down (180¬∞) -->
                    <g class="arrow-down">
                        <line x1="16" y1="16" x2="16" y2="29" stroke="#2F6EBA" stroke-width="2.5"/>
                        <polygon points="16,31 19,26 13,26" fill="#2F6EBA"/>
                        <polygon points="16,13 19,18 13,18" fill="#2F6EBA"/>
                    </g>
                    
                    <!-- Arrow 6: Down-Left (225¬∞) -->
                    <g class="arrow-down-left">
                        <line x1="16" y1="16" x2="6.8" y2="25.2" stroke="#2F6EBA" stroke-width="2.5"/>
                        <polygon points="4.9,27.1 12.2,23.8 7.6,21.4" fill="#2F6EBA"/>
                        <polygon points="14.2,17.8 20.1,14.9 16.6,12.2" fill="#2F6EBA"/>
                    </g>
                    
                    <!-- Arrow 7: Left (270¬∞) -->
                    <g class="arrow-left">
                        <line x1="16" y1="16" x2="3" y2="16" stroke="#2F6EBA" stroke-width="2.5"/>
                        <polygon points="1,16 6,19 6,13" fill="#2F6EBA"/>
                        <polygon points="19,16 14,19 14,13" fill="#2F6EBA"/>
                    </g>
                    
                    <!-- Arrow 8: Up-Left (315¬∞) -->
                    <g class="arrow-up-left">
                        <line x1="16" y1="16" x2="6.8" y2="6.8" stroke="#2F6EBA" stroke-width="2.5"/>
                        <polygon points="4.9,4.9 7.6,10.6 12.2,8.2" fill="#2F6EBA"/>
                        <polygon points="14.2,14.2 11.9,17.1 16.6,19.8" fill="#2F6EBA"/>
                    </g>
                    
                    <!-- BIGGER Central Hub with better styling -->
                    <circle cx="16" cy="16" r="5.5" fill="url(#hubGradient)" stroke="#0D47A1" stroke-width="1"/>
                    <circle cx="16" cy="16" r="3.5" fill="#66BB6A" opacity="0.9"/>
                    <circle cx="16" cy="16" r="1.5" fill="#FFF" opacity="0.6"/>
                </svg>
            </div>
            
            <h1>KHAOS AI Model Intelligence Dashboard</h1>
        </div>
        
        <div class="controls">
            <button id="research-btn" class="btn-primary" onclick="dashboard.triggerResearch()">üöÄ Trigger Research</button>
            <div id="research-status" style="font-size: 0.8em; color: #666; margin-top: 4px; text-align: center;">
                Loading...
            </div>
            <div id="progress-container" class="progress-container" style="display: none;">
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill"></div>
                </div>
                <div id="progress-text" class="progress-text">Starting research...</div>
            </div>
        </div>
    </div>

    <!-- Simple Dashboard Cards -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px; margin-bottom: 30px;">
        <!-- Command Center Card -->
        <div style="background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%); border-left: 4px solid #2F6EBA; border-radius: 10px; padding: 20px; box-shadow: 0 4px 15px rgba(47,110,186,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 10px;">
                <h2 style="color: #2F6EBA; margin: 0; font-size: 1.3em;">üéØ AI Intelligence Command Center</h2>
                <div style="display: flex; align-items: center; gap: 6px;">
                    <div style="width: 6px; height: 6px; background: #66BB6A; border-radius: 50%; animation: pulse 2s infinite;"></div>
                    <span style="font-size: 0.85em; color: #666;">Live Monitoring</span>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                <div style="background: rgba(255,255,255,0.8); padding: 10px; border-radius: 6px; display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.1em;">üìä</span>
                    <div>
                        <div style="font-size: 0.8em; color: #666;">System Status</div>
                        <div style="font-weight: 600; color: #333; display: flex; align-items: center; gap: 4px;">
                            <div style="width: 6px; height: 6px; background: #66BB6A; border-radius: 50%;"></div>
                            Operational
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.8); padding: 10px; border-radius: 6px; display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.1em;">üîÑ</span>
                    <div>
                        <div style="font-size: 0.8em; color: #666;">Last Research</div>
                        <div style="font-weight: 600; color: #333;" id="last-research-display">23m ago</div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.8); padding: 10px; border-radius: 6px; display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.1em;">‚è±Ô∏è</span>
                    <div>
                        <div style="font-size: 0.8em; color: #666;">Next Auto-Research</div>
                        <div style="font-weight: 600; color: #FFA726; font-family: monospace;" id="countdown-display">2h 33m</div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.8); padding: 10px; border-radius: 6px; display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.1em;">üóÑÔ∏è</span>
                    <div>
                        <div style="font-size: 0.8em; color: #666;">Database</div>
                        <div style="font-weight: 600; color: #333; display: flex; align-items: center; gap: 4px;">
                            <div style="width: 6px; height: 6px; background: #2F6EBA; border-radius: 50%;"></div>
                            Supabase Connected
                        </div>
                    </div>
                </div>
            </div>
            
            <div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="font-size: 0.8em; color: #666;">Research Cycle Progress</span>
                    <span style="font-size: 0.8em; color: #2F6EBA; font-weight: 600;" id="progress-percent">Loading...</span>
                </div>
                <div style="width: 100%; height: 6px; background: rgba(47,110,186,0.2); border-radius: 3px;">
                    <div style="height: 100%; background: linear-gradient(90deg, #2F6EBA, #6EC1E4); border-radius: 3px; width: 0%; transition: width 0.3s;" id="progress-bar-display"></div>
                </div>
            </div>
        </div>
        
        <!-- Ecosystem Intelligence Card -->
        <div style="background: linear-gradient(135deg, #fff 0%, #f0f7ff 100%); border-left: 4px solid #66BB6A; border-radius: 10px; padding: 20px; box-shadow: 0 4px 15px rgba(102,187,106,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 10px;">
                <h2 style="color: #2F6EBA; margin: 0; font-size: 1.3em;">üåä AI Ecosystem Intelligence</h2>
                <div style="display: flex; align-items: center; gap: 6px;">
                    <div style="width: 6px; height: 6px; background: #FFA726; border-radius: 50%; animation: pulse 2s infinite;"></div>
                    <span style="font-size: 0.85em; color: #666;">Live Data</span>
                </div>
            </div>
            
            <!-- Exact Number Display -->
            <div style="text-align: center; margin-bottom: 15px;">
                <div style="font-size: 2.2em; font-weight: 800; color: #2F6EBA; margin-bottom: 4px; font-family: 'Courier New', monospace;" id="ecosystem-exact-count">Loading...</div>
                <div style="font-size: 0.9em; font-weight: 600; color: #333;">Total AI Models</div>
                <div style="font-size: 0.8em; color: #666;">in Ecosystem</div>
                <div style="font-size: 0.75em; color: #999; margin-top: 4px; font-style: italic;" id="ecosystem-timestamp">Last scraped: Loading...</div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.7); border-radius: 6px; border-top: 2px solid #66BB6A;">
                    <div style="font-size: 1.3em; font-weight: 700; color: #66BB6A;" id="growth-rate-display">+125K</div>
                    <div style="font-size: 0.8em; color: #666;">Monthly Growth</div>
                </div>
                <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.7); border-radius: 6px; border-top: 2px solid #FFA726;">
                    <div style="font-size: 1.3em; font-weight: 700; color: #FFA726;" id="curated-count-display">165+</div>
                    <div style="font-size: 0.8em; color: #666;">Curated Models</div>
                </div>
            </div>
            
            <div style="background: rgba(255,255,255,0.6); padding: 12px; border-radius: 6px; border: 1px solid rgba(102,187,106,0.2);">
                <div style="font-size: 0.9em; line-height: 1.4; color: #333; margin-bottom: 8px;">
                    <strong>Intelligence Focus:</strong> We track the largest repository of AI models, showing <strong>15.6x growth in 30 months</strong> - the democratization of AI in real-time.
                </div>
                <div style="font-size: 0.8em; color: #555; line-height: 1.3;">
                    <strong style="color: #2F6EBA;">Scale:</strong> HuggingFace hosts <span id="ecosystem-total-text">1.9M+</span> models, we curate <span id="curated-total-text">165+</span> enterprise-grade
                </div>
            </div>
        </div>
    </div>

    <style>
    @keyframes pulse {
        0% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.2); opacity: 0.7; }
        100% { transform: scale(1); opacity: 1; }
    }

    @media (max-width: 768px) {
        div[style*="grid-template-columns: 1fr 1fr"] {
            grid-template-columns: 1fr !important;
            margin: 15px !important;
        }
    }
    </style>

    <!-- AI Model Release Timeline -->
    <div style="background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%); border-left: 4px solid #FFA726; border-radius: 10px; padding: 20px; margin: 20px; box-shadow: 0 4px 15px rgba(255,167,38,0.1);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 10px;">
            <h2 style="color: #2F6EBA; margin: 0; font-size: 1.3em;">üìÖ AI Model Release Timeline</h2>
            <div style="display: flex; align-items: center; gap: 10px;">
                <select id="timeline-provider-filter" style="padding: 6px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.85em;">
                    <option value="">All Providers</option>
                    <option value="OpenAI">OpenAI</option>
                    <option value="Google">Google</option>
                    <option value="Anthropic">Anthropic</option>
                    <option value="xAI">xAI</option>
                </select>
                <select id="timeline-year-filter" style="padding: 6px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.85em;">
                    <option value="">2018-2025</option>
                    <option value="2018">2018</option>
                    <option value="2019">2019</option>
                    <option value="2020">2020</option>
                    <option value="2021">2021</option>
                    <option value="2022">2022</option>
                    <option value="2023">2023</option>
                    <option value="2024">2024</option>
                    <option value="2025">2025</option>
                </select>
            </div>
        </div>

        <div id="timeline-container" style="position: relative; min-height: 600px;"></div>

        <!-- Timeline Legend -->
        <div style="display: flex; flex-wrap: wrap; gap: 15px; margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee; justify-content: center; font-size: 0.85em;">
            <div style="display: flex; align-items: center; gap: 6px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #10A37F;"></div>
                <span>OpenAI</span>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #4285F4;"></div>
                <span>Google</span>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #D97757;"></div>
                <span>Anthropic</span>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #000000;"></div>
                <span>xAI</span>
            </div>
            <div style="margin-left: 15px; padding-left: 15px; border-left: 2px solid #ddd; display: flex; gap: 12px;">
                <span style="color: #666;">‚óè Model Release</span>
                <span style="color: #666;">‚óÜ Product Launch</span>
                <span style="color: #666;">‚ñ≤ Announcement</span>
            </div>
        </div>
    </div>

    <div class="charts-container">
        <div class="chart-section khaos-card">
            <h2>üìä Provider Distribution</h2>
            <div id="provider-chart"></div>
        </div>
        
        <div class="chart-section khaos-card">
            <h2>üìà AI Democratization Timeline</h2>
            <p style="color: #666; margin-bottom: 15px;">The explosive growth of AI model ecosystem - 15.6x growth in 30 months</p>
            <div id="timeline-chart"></div>
            
            <!-- Timeline insights -->
            <div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                <div style="display: flex; gap: 20px; font-size: 0.9em; color: #666;">
                    <div><strong>Foundation Era</strong>: 2023 (121K ‚Üí 420K)</div>
                    <div><strong>Acceleration</strong>: 2024 (420K ‚Üí 1.05M)</div>
                    <div><strong>Exponential</strong>: 2025 (1.05M ‚Üí 1.89M+)</div>
                </div>
            </div>
        </div>
    </div>


    <div class="models-section khaos-card">
        <h2>üóÑÔ∏è All Models</h2>
        <div class="filter-controls">
            <select id="provider-filter">
                <option value="">All Providers</option>
            </select>
            <input type="text" id="search-filter" placeholder="üîç Search models...">
        </div>
        <div id="model-grid"></div>
        
        <!-- Professional Legend Section -->
        <div style="margin: 20px; margin-top: 30px;">
            <div style="background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%); border-left: 4px solid #2F6EBA; border-radius: 10px; padding: 20px; box-shadow: 0 4px 15px rgba(47,110,186,0.1); border: 1px solid rgba(47,110,186,0.1);">
                
                <!-- Legend Header -->
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee;">
                    <span style="font-size: 1.2em;">üìÖ</span>
                    <h3 style="color: #2F6EBA; margin: 0; font-size: 1.2em; font-weight: 700;">RELEASE DATE SOURCES</h3>
                </div>
                
                <!-- Legend Grid -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 12px;">
                    
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(255,255,255,0.7); border-radius: 6px; border: 1px solid rgba(108,193,228,0.2);">
                        <span style="font-size: 1.1em;">‚òÅÔ∏è</span>
                        <span style="font-size: 0.9em; color: #333; font-weight: 500;">HuggingFace upload date</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(255,255,255,0.7); border-radius: 6px; border: 1px solid rgba(139,195,74,0.2);">
                        <span style="font-size: 1.1em;">üìã</span>
                        <span style="font-size: 0.9em; color: #333; font-weight: 500;">Known release date</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(255,255,255,0.7); border-radius: 6px; border: 1px solid rgba(158,158,158,0.2);">
                        <span style="font-size: 1.1em;">üè¢</span>
                        <span style="font-size: 0.9em; color: #333; font-weight: 500;">Provider estimate</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(255,255,255,0.7); border-radius: 6px; border: 1px solid rgba(63,180,254,0.2);">
                        <span style="font-size: 1.1em;">üåä</span>
                        <span style="font-size: 0.9em; color: #333; font-weight: 500;">Ecosystem snapshot</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(255,255,255,0.7); border-radius: 6px; border: 1px solid rgba(255,167,38,0.2);">
                        <span style="font-size: 1.1em;">üìÖ</span>
                        <span style="font-size: 0.9em; color: #333; font-weight: 500;">Last modified</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(255,255,255,0.7); border-radius: 6px; border: 1px solid rgba(102,187,106,0.2);">
                        <span style="font-size: 1.1em;">üîÑ</span>
                        <span style="font-size: 0.9em; color: #333; font-weight: 500;">Updated date</span>
                    </div>
                    
                </div>
                
                <!-- Optional: Add a subtitle for context -->
                <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(47,110,186,0.1);">
                    <p style="font-size: 0.85em; color: #666; margin: 0; line-height: 1.4;">
                        <strong>Date Intelligence:</strong> We use multiple sources to provide the most accurate release dates possible. 
                        Icons indicate the source and reliability of each model's release date.
                    </p>
                </div>
                
            </div>
        </div>

        <!-- Capability Types Legend -->
        <div style="flex: 1; min-width: 300px;">
            <div style="background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%); border-left: 4px solid #66BB6A; border-radius: 10px; padding: 20px; box-shadow: 0 4px 15px rgba(102,187,106,0.1); border: 1px solid rgba(102,187,106,0.1);">
                
                <!-- Legend Header -->
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee;">
                    <span style="font-size: 1.2em;">üè∑Ô∏è</span>
                    <h3 style="color: #66BB6A; margin: 0; font-size: 1.2em; font-weight: 700;">CAPABILITY TYPES</h3>
                </div>
                
                <!-- Legend Grid -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
                    
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(255,255,255,0.7); border-radius: 6px; border: 1px solid rgba(25,118,210,0.2);">
                        <span class="capability-tag text-generation" style="font-size: 0.7em; padding: 3px 6px;">text-generation</span>
                        <span style="font-size: 1.2em;">üìï</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(255,255,255,0.7); border-radius: 6px; border: 1px solid rgba(56,142,60,0.2);">
                        <span class="capability-tag community" style="font-size: 0.7em; padding: 3px 6px;">community</span>
                        <span style="font-size: 1.2em;">ü§ù</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(255,255,255,0.7); border-radius: 6px; border: 1px solid rgba(245,124,0,0.2);">
                        <span class="capability-tag reasoning" style="font-size: 0.7em; padding: 3px 6px;">reasoning</span>
                        <span style="font-size: 1.2em;">üí≠</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(255,255,255,0.7); border-radius: 6px; border: 1px solid rgba(85,139,47,0.2);">
                        <span class="capability-tag enterprise" style="font-size: 0.7em; padding: 3px 6px;">enterprise</span>
                        <span style="font-size: 1.2em;">üè¶</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(255,255,255,0.7); border-radius: 6px; border: 1px solid rgba(0,105,92,0.2);">
                        <span class="capability-tag open-source" style="font-size: 0.7em; padding: 3px 6px;">open-source</span>
                        <span style="font-size: 1.2em;">üîì</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(255,255,255,0.7); border-radius: 6px; border: 1px solid rgba(194,33,107,0.2);">
                        <span class="capability-tag image-generation" style="font-size: 0.7em; padding: 3px 6px;">image-generation</span>
                        <span style="font-size: 1.2em;">üì∏</span>
                    </div>
                    
                </div>
                
                <!-- Optional: Add a subtitle for context -->
                <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(102,187,106,0.1);">
                    <p style="font-size: 0.85em; color: #666; margin: 0; line-height: 1.4;">
                        <strong>AI Capabilities:</strong> Each model is tagged with its primary capabilities and features. 
                        Tags are color-coded by capability type for easy identification.
                    </p>
                </div>
                
            </div>
        </div>

        <!-- Responsive styling for mobile -->
        <style>
        @media (max-width: 768px) {
            div[style*="grid-template-columns: repeat(auto-fit, minmax(240px, 1fr))"] {
                grid-template-columns: 1fr !important;
                gap: 8px !important;
            }
        }
        </style>
    </div>

    <!-- Professional Footer -->
    <div style="margin: 20px; margin-top: 15px;">
        <div style="background: linear-gradient(135deg, #fff 0%, #f0f7ff 100%); border-left: 4px solid #66BB6A; border-radius: 10px; padding: 16px; box-shadow: 0 2px 10px rgba(102,187,106,0.08); border: 1px solid rgba(102,187,106,0.1);">
            <div style="text-align: center; font-size: 0.9em; color: #555; line-height: 1.5;">
                <div style="margin-bottom: 8px;">
                    <strong style="color: #2F6EBA;">Ceterum censeo:</strong> SBaaS‚Ñ¢ ‚Äì Scaling Business as a Service is the way forward to Accelerate Growth! üöÄ
                </div>
                <div style="font-size: 0.85em; color: #666;">
                    <strong>Cost of Delay Estimator (CoDE)</strong> for postponing decisions ‚Äì you don't have to act now, 
                    but it's good to know the price and then think it through thoroughly. 
                    üëâ <a href="https://cotoaga.net/code/" target="_blank" style="color: #2F6EBA; text-decoration: none; font-weight: bold;">CoDE üßÆ</a>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Cloud-ready dashboard JavaScript
        // Rate limiting constants
        const RATE_LIMIT = {
            MAX_RUNS_PER_HOUR: 4,
            COOLDOWN_MINUTES: 60
        };

        // Rate limiting state (stored in localStorage)
        function getRateLimitState() {
            const stored = localStorage.getItem('khaos-research-rate-limit');
            if (!stored) {
                return { runs: [], lastRun: null };
            }
            
            try {
                const state = JSON.parse(stored);
                // Clean old runs (older than 1 hour)
                const oneHourAgo = Date.now() - (60 * 60 * 1000);
                state.runs = state.runs.filter(timestamp => timestamp > oneHourAgo);
                return state;
            } catch {
                return { runs: [], lastRun: null };
            }
        }

        function saveRateLimitState(state) {
            localStorage.setItem('khaos-research-rate-limit', JSON.stringify(state));
        }

        function addRunToRateLimit() {
            const state = getRateLimitState();
            const now = Date.now();
            state.runs.push(now);
            state.lastRun = now;
            saveRateLimitState(state);
        }

        function getRemainingRuns() {
            const state = getRateLimitState();
            return Math.max(0, RATE_LIMIT.MAX_RUNS_PER_HOUR - state.runs.length);
        }

        function getTimeUntilNextRun() {
            const state = getRateLimitState();
            if (!state.lastRun) return 0;
            
            const timeSinceLastRun = Date.now() - state.lastRun;
            const cooldownMs = RATE_LIMIT.COOLDOWN_MINUTES * 60 * 1000;
            
            if (timeSinceLastRun >= cooldownMs) return 0;
            return cooldownMs - timeSinceLastRun;
        }

        function formatTimeRemaining(ms) {
            const minutes = Math.ceil(ms / (60 * 1000));
            if (minutes <= 1) return "1 minute";
            return `${minutes} minutes`;
        }

        // Update the research button based on rate limit state
        function updateResearchButton() {
            const button = document.getElementById('research-btn');
            const statusEl = document.getElementById('research-status');
            
            if (!button) return;
            
            const remaining = getRemainingRuns();
            const timeUntilNext = getTimeUntilNextRun();
            
            if (remaining === 0 && timeUntilNext > 0) {
                // Rate limited
                button.disabled = true;
                button.textContent = 'üöÄ Rate Limited';
                button.style.opacity = '0.5';
                
                if (statusEl) {
                    statusEl.innerHTML = `‚è±Ô∏è Wait until <span id="countdown-timer">${formatTimeRemaining(timeUntilNext)}</span>`;
                    
                    // Start countdown timer
                    updateCountdownTimer();
                }
            } else {
                // Available
                button.disabled = false;
                button.textContent = 'üöÄ Trigger Research';
                button.style.opacity = '1';
                
                if (statusEl) {
                    if (remaining > 0) {
                        statusEl.innerHTML = `<span style="color: #66BB6A; font-weight: 600;">${remaining} runs left</span>`;
                    } else {
                        statusEl.innerHTML = '<span style="color: #66BB6A; font-weight: 600;">Ready</span>';
                    }
                }
            }
        }

        // Countdown timer for rate limit
        function updateCountdownTimer() {
            const timerEl = document.getElementById('countdown-timer');
            if (!timerEl) return;
            
            const timeUntilNext = getTimeUntilNextRun();
            
            if (timeUntilNext <= 0) {
                updateResearchButton(); // Refresh the entire button state
                return;
            }
            
            timerEl.textContent = formatTimeRemaining(timeUntilNext);
            
            // Update every 30 seconds
            setTimeout(updateCountdownTimer, 30000);
        }

        class CloudDashboard {
            constructor() {
                this.apiBase = window.location.origin;
                this.modelData = null;
                this.lastUpdate = null;
                this.currentModels = [];
            }

            formatModelDate(created, metadata = null) {
                // Handle various timestamp formats
                if (!created || created === null || created === undefined) {
                    return this.getDateSourceLabel('unknown', metadata);
                }
                
                let timestamp;
                if (typeof created === 'string') {
                    timestamp = new Date(created);
                } else if (typeof created === 'number') {
                    // Handle both seconds and milliseconds timestamps
                    timestamp = created > 1000000000000 
                        ? new Date(created)           // Already milliseconds
                        : new Date(created * 1000);   // Convert seconds to milliseconds
                } else {
                    return this.getDateSourceLabel('invalid', metadata);
                }
                
                // Check if date is valid
                if (isNaN(timestamp.getTime())) {
                    return this.getDateSourceLabel('invalid', metadata);
                }
                
                // Format date: YYYY-MM-DD
                const dateStr = timestamp.getFullYear() + '-' + 
                       String(timestamp.getMonth() + 1).padStart(2, '0') + '-' + 
                       String(timestamp.getDate()).padStart(2, '0');
                
                return this.getDateSourceLabel(dateStr, metadata);
            }
            
            getDateSourceLabel(dateStr, metadata) {
                if (!metadata || !metadata.dateSource) {
                    return dateStr === 'unknown' ? '‚ùì Unknown release date' : 
                           dateStr === 'invalid' ? '‚ùì Invalid date' : 'üìÖ ' + dateStr;
                }
                
                const sourceLabels = {
                    'last-modified': 'üìÖ ',
                    'upload-date': 'üì§ ',
                    'updated': 'üîÑ ',
                    'ecosystem-snapshot': 'üåä ',
                    'rawDate-metadata': 'üì§ ',
                    'known-date': 'üìã ',
                    'provider-fallback': 'üè¢ ',
                    'unknown': '‚ùì '
                };
                
                const icon = sourceLabels[metadata.dateSource] || 'üì§ ';
                
                if (dateStr === 'unknown') {
                    return '‚ùì Unknown release date';
                } else if (dateStr === 'invalid') {
                    return '‚ùì Invalid date';
                } else {
                    return icon + dateStr;
                }
            }

            async loadData() {
                try {
                    const response = await fetch(`${this.apiBase}/api/data`);
                    const result = await response.json();
                    
                    if (result.success) {
                        this.modelData = result.data;
                        this.currentModels = Object.values(this.modelData.models || {});
                        this.lastUpdate = new Date();
                        return true;
                    } else {
                        throw new Error(result.error);
                    }
                } catch (error) {
                    console.error('Failed to load data:', error);
                    this.showSupabaseError();
                    return false;
                }
            }

            async triggerResearch() {
                const remaining = getRemainingRuns();
                const timeUntilNext = getTimeUntilNextRun();
                
                if (remaining === 0 && timeUntilNext > 0) {
                    alert(`Rate limit exceeded. Please wait ${formatTimeRemaining(timeUntilNext)} before triggering another research cycle.`);
                    return;
                }
                
                try {
                    // Add to rate limit before making request
                    addRunToRateLimit();
                    
                    // Update button state immediately
                    updateResearchButton();
                    
                    // Show progress bar
                    this.showProgress('Starting research...', 10);
                    
                    // Disable button
                    const btn = document.getElementById('research-btn');
                    btn.disabled = true;
                    btn.textContent = 'üîÑ Researching...';
                    
                    this.showProgress('Gathering AI model data...', 30);
                    
                    const response = await fetch(`${this.apiBase}/api/research`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    this.showProgress('Processing results...', 70);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const result = await response.json();
                    console.log('Research triggered:', result);
                    
                    if (result.success) {
                        this.showProgress(`Found ${result.discoveries} discoveries!`, 90);
                        
                        // Wait and reload data
                        setTimeout(async () => {
                            this.showProgress('Updating dashboard...', 95);
                            const loaded = await this.loadData();
                            if (loaded) {
                                this.renderAll();
                                this.showProgress('Research complete!', 100);
                                setTimeout(() => this.hideProgress(), 1000);
                            }
                        }, 1500);
                    } else {
                        throw new Error(result.error || 'Research failed');
                    }
                } catch (error) {
                    console.error('Research failed:', error);
                    this.hideProgress();
                    alert('Research failed: ' + error.message);
                } finally {
                    // Update button state based on rate limiting
                    setTimeout(() => {
                        updateResearchButton();
                    }, 3000);
                }
            }
            
            showProgress(text, percentage) {
                const container = document.getElementById('progress-container');
                const fill = document.getElementById('progress-fill');
                const textEl = document.getElementById('progress-text');
                
                container.style.display = 'block';
                fill.style.width = percentage + '%';
                textEl.textContent = text;
            }
            
            hideProgress() {
                const container = document.getElementById('progress-container');
                container.style.display = 'none';
            }


            updateStatus(status, text) {
                // Status updates now handled in updateSystemStatus
                // Removed console logging for cleaner output
            }

            async init() {
                const loaded = await this.loadData();
                if (loaded) {
                    this.renderAll();
                } else {
                    this.showEmptyState();
                }

                // Update progress bar immediately
                this.updateResearchProgress();

                // Set up auto-refresh every 5 minutes
                setInterval(() => {
                    this.loadData().then(loaded => {
                        if (loaded) this.renderAll();
                    });
                }, 5 * 60 * 1000);

                // Update progress bar every minute
                setInterval(() => {
                    this.updateResearchProgress();
                }, 60 * 1000);
            }

            renderAll() {
                if (!this.modelData) return;
                
                // Convert Supabase format to dashboard format
                this.currentModels = Object.values(this.modelData.models || {});
                
                this.updateStats();
                this.renderProviderChart();
                this.renderTimelineChart();
                this.renderModelGrid();
                this.updateFilters();
                this.updateNiceDashboard(); // Add this line
                
                // Start countdown timer updates
                if (window.countdownTimer) clearInterval(window.countdownTimer);
                window.countdownTimer = setInterval(() => this.updateNiceDashboard(), 60000); // Update every minute
            }

            // FIXED: Complete dashboard updates with real data
            updateStats() {
                if (!this.modelData) return;
                
                const totalModels = this.currentModels.length;
                const providers = new Set(this.currentModels.map(m => m.provider)).size;
                const lastUpdate = this.modelData.metadata?.lastUpdate || 'Unknown';
                
                // Update old stats elements (if they exist)
                const totalModelsEl = document.getElementById('total-models');
                if (totalModelsEl) totalModelsEl.textContent = totalModels;
                
                const totalProvidersEl = document.getElementById('total-providers');
                if (totalProvidersEl) totalProvidersEl.textContent = providers;
                
                // Update strategic dashboard with REAL data
                this.updateStrategicDashboard(totalModels, lastUpdate);
            }

            updateStrategicDashboard(totalModels, lastUpdate) {
                // Update ecosystem count with REAL number, not hardcoded
                const ecosystemCountEl = document.getElementById('ecosystem-live-count');
                if (ecosystemCountEl) {
                    // Use actual scraped ecosystem count from data
                    const ecosystemCount = this.modelData?.metadata?.ecosystemTotal || 1890000;
                    ecosystemCountEl.textContent = this.formatLargeNumber(ecosystemCount);
                }
                
                // Update curated count with actual data
                const curatedCountEl = document.getElementById('curated-count-display');
                if (curatedCountEl) {
                    curatedCountEl.textContent = `${totalModels}+`;
                }
                
                // Update all text references to curated count
                const curatedTotalTextEl = document.getElementById('curated-total-text');
                if (curatedTotalTextEl) {
                    curatedTotalTextEl.textContent = `${totalModels}+`;
                }
                
                // Update ecosystem total text
                const ecosystemTotalTextEl = document.getElementById('ecosystem-total-text');
                if (ecosystemTotalTextEl) {
                    const ecosystemCount = this.modelData?.metadata?.ecosystemTotal || 1890000;
                    ecosystemTotalTextEl.textContent = this.formatLargeNumber(ecosystemCount);
                }
                
                // Update last research time
                const lastResearchEl = document.getElementById('last-research-time');
                if (lastResearchEl && lastUpdate !== 'Unknown') {
                    const timeDiff = new Date() - new Date(lastUpdate);
                    const hoursAgo = Math.floor(timeDiff / (1000 * 60 * 60));
                    const minutesAgo = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
                    
                    if (hoursAgo > 0) {
                        lastResearchEl.textContent = `${hoursAgo}h ago`;
                    } else {
                        lastResearchEl.textContent = `${minutesAgo}m ago`;
                    }
                }
                
                // FIXED: Update research progress with correct calculation
                this.updateResearchProgress(lastUpdate);
                
                // Update countdown timer
                this.updateCountdown();
            }

            // FIXED: Research progress calculation
            updateResearchProgress(lastUpdate) {
                const progressBarEl = document.getElementById('research-progress-bar');
                const progressPercentageEl = document.getElementById('cycle-percentage');
                
                if (!progressBarEl || !progressPercentageEl || lastUpdate === 'Unknown') {
                    if (progressBarEl) progressBarEl.style.width = '0%';
                    if (progressPercentageEl) progressPercentageEl.textContent = '0%';
                    return;
                }
                
                try {
                    const lastUpdateTime = new Date(lastUpdate);
                    const now = new Date();
                    const timeSinceUpdate = now - lastUpdateTime;
                    
                    // 6-hour cycle = 6 * 60 * 60 * 1000 = 21,600,000 ms
                    const sixHoursMs = 6 * 60 * 60 * 1000;
                    
                    // Calculate progress as percentage of 6-hour cycle
                    const progressRatio = Math.min(timeSinceUpdate / sixHoursMs, 1);
                    const progressPercent = Math.round(progressRatio * 100);
                    
                    progressBarEl.style.width = `${progressPercent}%`;
                    progressPercentageEl.textContent = `${progressPercent}%`;
                    
                } catch (error) {
                    console.warn('Error calculating research progress:', error);
                    progressBarEl.style.width = '0%';
                    progressPercentageEl.textContent = '0%';
                }
            }

            // Update countdown timer
            updateCountdown() {
                const countdownEl = document.getElementById('research-countdown');
                if (!countdownEl) return;
                
                const now = new Date();
                const nextCycle = new Date();
                
                // Calculate next 6-hour mark
                const currentHour = now.getHours();
                const nextSixHourMark = Math.ceil(currentHour / 6) * 6;
                
                nextCycle.setHours(nextSixHourMark, 0, 0, 0);
                
                // If next cycle is past midnight, it's tomorrow
                if (nextSixHourMark >= 24) {
                    nextCycle.setDate(nextCycle.getDate() + 1);
                    nextCycle.setHours(0, 0, 0, 0);
                }
                
                const timeDiff = nextCycle - now;
                const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
                
                countdownEl.textContent = `${hours}h ${minutes}m`;
            }

            // Helper function to format large numbers
            formatLargeNumber(num) {
                if (num >= 1000000) {
                    return (num / 1000000).toFixed(1) + 'M+';
                } else if (num >= 1000) {
                    return (num / 1000).toFixed(0) + 'K+';
                }
                return num.toString();
            }

            getExactEcosystemCount() {
                // Multiple strategies to get the exact count
                
                // Strategy 1: From ecosystem-ocean model metadata
                const ecosystemModel = this.currentModels?.find(m => m.id === 'ecosystem-ocean');
                if (ecosystemModel?.metadata?.totalModels) {
                    return ecosystemModel.metadata.totalModels;
                }
                
                // Strategy 2: From modelData metadata
                if (this.modelData?.metadata?.ecosystemTotal) {
                    return this.modelData.metadata.ecosystemTotal;
                }
                
                // Strategy 3: Look for any model with totalModels in metadata
                for (const model of (this.currentModels || [])) {
                    if (model.metadata?.totalModels && model.metadata.totalModels > 1000000) {
                        return model.metadata.totalModels;
                    }
                }
                
                // Fallback: Return null to indicate we need to fetch
                return null;
            }

            getEcosystemTimestamp() {
                // Get timestamp of when the ecosystem was last scraped
                const ecosystemModel = this.currentModels?.find(m => m.id === 'ecosystem-ocean');
                if (ecosystemModel?.metadata?.lastScraped) {
                    return new Date(ecosystemModel.metadata.lastScraped);
                }
                
                // Fallback to last update time
                if (this.modelData?.metadata?.lastUpdate) {
                    return new Date(this.modelData.metadata.lastUpdate);
                }
                
                return new Date(); // Current time as fallback
            }

            formatExactNumber(number) {
                if (!number || isNaN(number)) return 'Loading...';
                
                // European formatting: 1.865.321 (dots for thousands)
                return number.toLocaleString('de-DE');
            }

            formatTimestamp(date) {
                if (!date) return 'Unknown';
                
                // Format: 2025-07-10 8:53
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                
                return `${year}-${month}-${day} ${hours}:${minutes}`;
            }

            updateAllEcosystemReferences(exactCount) {
                if (!exactCount) return;
                
                // Update all text references to ecosystem total
                const ecosystemTextElements = [
                    'ecosystem-total-text',
                    'ecosystem-count-display',
                    'ecosystem-live-count'
                ];
                
                ecosystemTextElements.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.textContent = this.formatExactNumber(exactCount);
                    }
                });
                
                // Update narrative text with exact number
                const narrativeText = document.querySelector('.detail-text');
                if (narrativeText && narrativeText.textContent.includes('HuggingFace hosts')) {
                    const curatedCount = this.currentModels ? this.currentModels.filter(m => m.id !== 'ecosystem-ocean').length : 165;
                    narrativeText.textContent = `HuggingFace hosts ${this.formatExactNumber(exactCount)} models, we curate ${curatedCount}+ enterprise-grade`;
                }
            }

            // Simple function to update the nice dashboard
            updateNiceDashboard() {
                if (!this.modelData) return;
                
                // Update last research time
                const lastResearchEl = document.getElementById('last-research-display');
                if (lastResearchEl && this.modelData.metadata?.lastUpdate) {
                    const timeDiff = new Date() - new Date(this.modelData.metadata.lastUpdate);
                    const hoursAgo = Math.floor(timeDiff / (1000 * 60 * 60));
                    const minutesAgo = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
                    
                    if (hoursAgo > 0) {
                        lastResearchEl.textContent = `${hoursAgo}h ago`;
                    } else {
                        lastResearchEl.textContent = `${minutesAgo}m ago`;
                    }
                }
                
                // Update curated count
                const curatedEl = document.getElementById('curated-count-display');
                const curatedTextEl = document.getElementById('curated-total-text');
                if (curatedEl && this.currentModels) {
                    curatedEl.textContent = `${this.currentModels.length}+`;
                    if (curatedTextEl) curatedTextEl.textContent = `${this.currentModels.length}+`;
                }
                
                // Update ecosystem count with EXACT numbers and fallback detection
                const exactEcosystemCount = getExactEcosystemCount();
                const ecosystemTimestamp = getEcosystemTimestamp();
                
                // Get the real ecosystem count from the ecosystem-ocean model
                const ecosystemModel = this.currentModels?.find(m => m.id === 'ecosystem-ocean');
                const realCount = ecosystemModel?.metadata?.totalModels;
                
                const exactCountEl = document.getElementById('ecosystem-exact-count');
                const timestampEl = document.getElementById('ecosystem-timestamp');
                
                if (exactCountEl && realCount) {
                    // Check if it's the fallback (exactly 1,800,000)
                    if (realCount === 1800000) {
                        exactCountEl.innerHTML = `
                            <span style="color: #FFA726;">${formatExactNumber(realCount)}</span>
                            <span style="font-size: 0.6em; color: #f44336; margin-left: 8px;">FALLBACK</span>
                        `;
                    } else {
                        exactCountEl.innerHTML = `
                            <span style="color: #66BB6A;">${formatExactNumber(realCount)}</span>
                            <span style="font-size: 0.6em; color: #66BB6A; margin-left: 8px;">LIVE</span>
                        `;
                    }
                }
                
                // Update timestamp with status indicator
                if (timestampEl && ecosystemModel?.metadata?.lastScraped) {
                    const timestamp = new Date(ecosystemModel.metadata.lastScraped);
                    if (realCount === 1800000) {
                        timestampEl.textContent = `‚ö†Ô∏è Scraping failed: ${formatTimestamp(timestamp)}`;
                        timestampEl.style.color = '#f44336';
                    } else {
                        timestampEl.textContent = `‚úÖ Scraped: ${formatTimestamp(timestamp)}`;
                        timestampEl.style.color = '#66BB6A';
                    }
                }
                
                // Update all other references to use exact count
                updateAllEcosystemReferences(exactEcosystemCount || realCount);
                
                // Update countdown
                const countdownEl = document.getElementById('countdown-display');
                if (countdownEl) {
                    const now = new Date();
                    const nextCycle = new Date();
                    nextCycle.setHours(Math.ceil(now.getHours() / 6) * 6, 0, 0, 0);
                    
                    const timeDiff = nextCycle - now;
                    const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                    const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
                    
                    countdownEl.textContent = `${hours}h ${minutes}m`;
                }
                
                // Update progress bar
                const progressBarEl = document.getElementById('progress-bar-display');
                const progressPercentEl = document.getElementById('progress-percent');
                if (progressBarEl && progressPercentEl) {
                    if (this.modelData.metadata?.lastUpdate) {
                        const timeSinceUpdate = new Date() - new Date(this.modelData.metadata.lastUpdate);
                        const sixHoursMs = 6 * 60 * 60 * 1000;
                        const progress = Math.min((timeSinceUpdate / sixHoursMs) * 100, 100);
                        
                        progressBarEl.style.width = `${Math.round(progress)}%`;
                        progressPercentEl.textContent = `${Math.round(progress)}%`;
                    } else {
                        // Fallback: assume we're in the middle of a cycle if no data
                        progressBarEl.style.width = '50%';
                        progressPercentEl.textContent = '50%';
                    }
                }
            }


            renderProviderChart() {
                const container = document.getElementById('provider-chart');
                container.innerHTML = '';
                
                if (!this.currentModels || this.currentModels.length === 0) return;
                
                // Calculate provider distribution (exclude ecosystem model)
                const providerCounts = {};
                this.currentModels.forEach(model => {
                    if (model.id !== 'ecosystem-ocean') { // Exclude the ecosystem overview
                        const provider = model.provider || 'Unknown';
                        providerCounts[provider] = (providerCounts[provider] || 0) + 1;
                    }
                });
                
                // Convert to array and sort by count
                const data = Object.entries(providerCounts)
                    .map(([provider, count]) => ({ provider, count }))
                    .sort((a, b) => b.count - a.count);
                
                if (data.length === 0) return;
                
                // Chart dimensions
                const margin = { top: 20, right: 60, bottom: 20, left: 100 };
                const width = 500 - margin.left - margin.right;
                const height = Math.max(300, data.length * 35) - margin.top - margin.bottom;
                
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width + margin.left + margin.right)
                    .attr('height', height + margin.top + margin.bottom);
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Scales
                const xScale = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.count)])
                    .range([0, width]);
                
                const yScale = d3.scaleBand()
                    .domain(data.map(d => d.provider))
                    .range([0, height])
                    .padding(0.1);
                
                // Color scale with better colors
                const colorScale = d3.scaleOrdinal()
                    .domain(data.map(d => d.provider))
                    .range([
                        '#2F6EBA', '#66BB6A', '#FFA726', '#6EC1E4', '#AB47BC',
                        '#5C6BC0', '#26A69A', '#FF7043', '#8D6E63', '#78909C'
                    ]);
                
                // Create bars
                const bars = g.selectAll('.bar')
                    .data(data)
                    .enter()
                    .append('g')
                    .attr('class', 'bar-group')
                    .attr('transform', d => `translate(0, ${yScale(d.provider)})`);
                
                // Bar rectangles with animation
                bars.append('rect')
                    .attr('class', 'bar')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', 0) // Start at 0 for animation
                    .attr('height', yScale.bandwidth())
                    .attr('fill', d => colorScale(d.provider))
                    .attr('rx', 3) // Rounded corners
                    .transition()
                    .duration(800)
                    .attr('width', d => xScale(d.count));
                
                // Value labels on bars
                bars.append('text')
                    .attr('class', 'value-label')
                    .attr('x', d => xScale(d.count) + 5)
                    .attr('y', yScale.bandwidth() / 2)
                    .attr('dy', '0.35em')
                    .style('font-size', '12px')
                    .style('font-weight', '600')
                    .style('fill', '#333')
                    .style('opacity', 0) // Start invisible for animation
                    .text(d => d.count)
                    .transition()
                    .delay(400)
                    .duration(400)
                    .style('opacity', 1);
                
                // Provider labels (y-axis)
                g.selectAll('.provider-label')
                    .data(data)
                    .enter()
                    .append('text')
                    .attr('class', 'provider-label')
                    .attr('x', -10)
                    .attr('y', d => yScale(d.provider) + yScale.bandwidth() / 2)
                    .attr('dy', '0.35em')
                    .style('text-anchor', 'end')
                    .style('font-size', '12px')
                    .style('font-weight', '500')
                    .style('fill', '#333')
                    .text(d => d.provider);
                
                // Add subtle grid lines
                const xAxis = d3.axisBottom(xScale)
                    .ticks(5)
                    .tickSize(-height)
                    .tickFormat('');
                
                g.append('g')
                    .attr('class', 'grid')
                    .attr('transform', `translate(0, ${height})`)
                    .call(xAxis)
                    .selectAll('line')
                    .style('stroke', '#e0e0e0')
                    .style('stroke-width', 1);
                
                // Remove domain line
                g.select('.grid .domain').remove();
                
                // Add chart title with total count
                const totalCount = data.reduce((sum, d) => sum + d.count, 0);
                container.insertAdjacentHTML('afterbegin', 
                    `<div style="text-align: center; margin-bottom: 10px; font-size: 0.9em; color: #666;">
                        <strong>${totalCount} curated models</strong> from ${data.length} providers
                    </div>`
                );
            }

            renderTimelineChart() {
                const container = document.getElementById('timeline-chart');
                container.innerHTML = '';
                
                // Timeline data with growth phases - AI democratization story
                const timelineData = [
                    // Foundation Era (2023)
                    { date: '2023-01', models: 121000, phase: 'foundation', type: 'historical' },
                    { date: '2023-06', models: 239000, phase: 'foundation', type: 'historical' },
                    { date: '2023-10', models: 371000, phase: 'foundation', type: 'historical' },
                    { date: '2023-12', models: 420000, phase: 'foundation', type: 'interpolated' },
                    
                    // Acceleration Phase (2024)
                    { date: '2024-03', models: 510000, phase: 'acceleration', type: 'interpolated' },
                    { date: '2024-06', models: 645000, phase: 'acceleration', type: 'interpolated' },
                    { date: '2024-09', models: 825000, phase: 'acceleration', type: 'interpolated' },
                    { date: '2024-12', models: 1050000, phase: 'acceleration', type: 'milestone' },
                    
                    // Exponential Era (2025)
                    { date: '2025-01', models: 1140000, phase: 'exponential', type: 'interpolated' },
                    { date: '2025-03', models: 1350000, phase: 'exponential', type: 'interpolated' },
                    { date: '2025-05', models: 1600000, phase: 'exponential', type: 'interpolated' },
                    { date: '2025-07', models: 1890000, phase: 'exponential', type: 'current-estimate' }
                ];

                const width = 600;
                const height = 300;
                const margin = { top: 30, right: 30, bottom: 60, left: 80 };
                
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                // Parse dates and set up scales
                const parseDate = d3.timeParse('%Y-%m');
                timelineData.forEach(d => {
                    d.parsedDate = parseDate(d.date);
                });

                const xScale = d3.scaleTime()
                    .domain(d3.extent(timelineData, d => d.parsedDate))
                    .range([margin.left, width - margin.right]);

                const yScale = d3.scaleLinear()
                    .domain([0, d3.max(timelineData, d => d.models) * 1.1])
                    .range([height - margin.bottom, margin.top]);

                // Growth phases background
                const phases = [
                    { name: 'Foundation Era', start: '2023-01', end: '2023-12', color: '#2F6EBA' },
                    { name: 'Acceleration Phase', start: '2024-01', end: '2024-12', color: '#6EC1E4' },
                    { name: 'Exponential Era', start: '2025-01', end: '2025-07', color: '#66BB6A' }
                ];

                phases.forEach(phase => {
                    const startX = xScale(parseDate(phase.start));
                    const endX = xScale(parseDate(phase.end));
                    
                    svg.append('rect')
                        .attr('x', startX)
                        .attr('y', margin.top)
                        .attr('width', endX - startX)
                        .attr('height', height - margin.top - margin.bottom)
                        .attr('fill', phase.color)
                        .attr('opacity', 0.1);

                    // Phase labels
                    svg.append('text')
                        .attr('x', startX + (endX - startX) / 2)
                        .attr('y', margin.top + 15)
                        .attr('text-anchor', 'middle')
                        .style('font-size', '11px')
                        .style('font-weight', 'bold')
                        .style('fill', phase.color)
                        .text(phase.name);
                });

                // Create line generator
                const line = d3.line()
                    .x(d => xScale(d.parsedDate))
                    .y(d => yScale(d.models))
                    .curve(d3.curveMonotoneX);

                // Add the growth line
                svg.append('path')
                    .datum(timelineData)
                    .attr('fill', 'none')
                    .attr('stroke', '#2F6EBA')
                    .attr('stroke-width', 3)
                    .attr('d', line);

                // Add data points with different styles
                const pointColors = {
                    'historical': '#2F6EBA',
                    'milestone': '#66BB6A',
                    'interpolated': '#6EC1E4',
                    'current-estimate': '#FFA726'
                };

                svg.selectAll('.data-point')
                    .data(timelineData)
                    .enter()
                    .append('circle')
                    .attr('class', 'data-point')
                    .attr('cx', d => xScale(d.parsedDate))
                    .attr('cy', d => yScale(d.models))
                    .attr('r', d => d.type === 'milestone' ? 6 : (d.type === 'historical' ? 5 : 3))
                    .attr('fill', d => pointColors[d.type])
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 2);

                // Add axes
                svg.append('g')
                    .attr('transform', `translate(0,${height - margin.bottom})`)
                    .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat('%Y-%m')));

                svg.append('g')
                    .attr('transform', `translate(${margin.left},0)`)
                    .call(d3.axisLeft(yScale).tickFormat(d => {
                        if (d >= 1000000) return (d / 1000000).toFixed(1) + 'M';
                        if (d >= 1000) return (d / 1000).toFixed(0) + 'K';
                        return d.toString();
                    }));

                // Add axis labels
                svg.append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', 0)
                    .attr('x', 0 - (height / 2))
                    .attr('dy', '1em')
                    .style('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .text('AI Models (HuggingFace)');

                svg.append('text')
                    .attr('transform', `translate(${width / 2}, ${height - 10})`)
                    .style('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .text('Timeline');

                // Add key insights
                const insights = [
                    '15.6x growth in 30 months',
                    'Current: ~125K models/month',
                    'Inflection: Mid-2024'
                ];

                const insightContainer = svg.append('g')
                    .attr('transform', `translate(${width - margin.right - 10}, ${margin.top + 10})`);

                insights.forEach((insight, i) => {
                    insightContainer.append('text')
                        .attr('x', 0)
                        .attr('y', i * 15)
                        .attr('text-anchor', 'end')
                        .style('font-size', '10px')
                        .style('font-weight', 'bold')
                        .style('fill', '#666')
                        .text(insight);
                });

                // Add milestone marker for 1M models
                const millionPoint = timelineData.find(d => d.models >= 1000000);
                if (millionPoint) {
                    svg.append('line')
                        .attr('x1', xScale(millionPoint.parsedDate))
                        .attr('x2', xScale(millionPoint.parsedDate))
                        .attr('y1', yScale(millionPoint.models))
                        .attr('y2', yScale(millionPoint.models) - 20)
                        .attr('stroke', '#66BB6A')
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', '5,5');

                    svg.append('text')
                        .attr('x', xScale(millionPoint.parsedDate))
                        .attr('y', yScale(millionPoint.models) - 25)
                        .attr('text-anchor', 'middle')
                        .style('font-size', '10px')
                        .style('font-weight', 'bold')
                        .style('fill', '#66BB6A')
                        .text('1M Models');
                }
            }

            // Capability tags rendering function
            renderCapabilityTags(capabilities) {
                // Handle empty or missing capabilities
                if (!capabilities || !Array.isArray(capabilities) || capabilities.length === 0) {
                    return '<span class="capability-tag general">general</span>';
                }
                
                // Generate tags for capabilities
                const tags = capabilities.map(capability => {
                    const cleanCap = capability.toLowerCase().replace(/[^a-z0-9-]/g, '');
                    return `<span class="capability-tag ${cleanCap}">${capability}</span>`;
                }).join('');
                
                return tags;
            }

            // Debug function - run in browser console
            debugCapabilityTags() {
                console.log('üîç Debugging capability tags...');
                
                if (!this.currentModels) {
                    console.log('‚ùå No currentModels found');
                    return;
                }
                
                console.log('üìä Total models:', this.currentModels.length);
                
                this.currentModels.forEach((model, index) => {
                    console.log(`Model ${index + 1}: ${model.id}`);
                    console.log(`  Provider: ${model.provider}`);
                    console.log(`  Capabilities:`, model.capabilities);
                    
                    if (model.capabilities && Array.isArray(model.capabilities)) {
                        console.log(`  ‚úÖ Has ${model.capabilities.length} capabilities`);
                        model.capabilities.forEach(cap => {
                            console.log(`    - ${cap}`);
                        });
                    } else {
                        console.log(`  ‚ùå No valid capabilities array`);
                    }
                    
                    console.log('---');
                });
                
                // Test the render function directly
                const testCapabilities = ['text-generation', 'community', 'reasoning'];
                console.log('üß™ Testing renderCapabilityTags with:', testCapabilities);
                const result = this.renderCapabilityTags(testCapabilities);
                console.log('üß™ Result:', result);
            }

            // Model grid rendering with capability tags
            renderModelGrid() {
                const container = document.getElementById('model-grid');
                if (!container || !this.currentModels) return;
                
                // Filter models for display
                const modelsToShow = this.currentModels.filter(model => {
                    if (model.id === 'ecosystem-ocean') return false;
                    
                    const searchTerm = document.getElementById('search-filter')?.value.toLowerCase() || '';
                    const providerFilter = document.getElementById('provider-filter')?.value || '';
                    
                    const matchesSearch = !searchTerm || 
                        model.id.toLowerCase().includes(searchTerm) ||
                        model.provider.toLowerCase().includes(searchTerm);
                    
                    const matchesProvider = !providerFilter || model.provider === providerFilter;
                    
                    return matchesSearch && matchesProvider;
                });
                
                // Log data updates for monitoring
                console.log(`üìä KHAOS-Researcher: Displaying ${modelsToShow.length}/${this.currentModels.length} models`);
                
                container.innerHTML = modelsToShow.map(model => {
                    // Log model data for research tracking
                    console.log(`üîç ${model.provider}/${model.id}: [${model.capabilities?.join(', ') || 'no capabilities'}]`);
                    
                    const actualCapabilities = model.capabilities || [];
                    const capabilityTagsHtml = this.renderCapabilityTags(actualCapabilities);
                    const dateInfo = this.formatModelDate(model.created, model.metadata);
                    
                    return `
                        <div class="model-card">
                            <h3 class="model-title">${model.id}</h3>
                            <div class="model-info">
                                <div class="info-row">
                                    <span class="info-label">Provider:</span>
                                    <span class="info-value">${model.provider}</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Capabilities:</span>
                                    <div class="capability-tags">
                                        ${capabilityTagsHtml}
                                    </div>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Released:</span>
                                    <span class="info-value">
                                        <span class="date-icon">‚òÅÔ∏è</span>
                                        ${dateInfo}
                                    </span>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            updateFilters() {
                const providerFilter = document.getElementById('provider-filter');
                const providers = [...new Set(this.currentModels.map(m => m.provider))].sort();
                
                // Store current selection
                const currentSelection = providerFilter.value;
                
                providerFilter.innerHTML = '<option value="">All Providers</option>';
                providers.forEach(provider => {
                    const option = document.createElement('option');
                    option.value = provider;
                    option.textContent = provider;
                    if (provider === currentSelection) {
                        option.selected = true;
                    }
                    providerFilter.appendChild(option);
                });
                
                // Add event listeners if not already added
                if (!providerFilter.hasAttribute('data-listener-added')) {
                    providerFilter.addEventListener('change', () => this.renderModelGrid());
                    providerFilter.setAttribute('data-listener-added', 'true');
                }
                
                const searchFilter = document.getElementById('search-filter');
                if (!searchFilter.hasAttribute('data-listener-added')) {
                    searchFilter.addEventListener('input', () => this.renderModelGrid());
                    searchFilter.setAttribute('data-listener-added', 'true');
                }
            }

            showEmptyState() {
                document.getElementById('model-grid').innerHTML = `
                    <div class="empty-state">
                        <h3>üîÑ Initializing KHAOS-Researcher...</h3>
                        <p>Triggering first research cycle...</p>
                        <div class="tars-insight">
                            The beauty of intelligence systems lies not in their complexity, but in their ability to make the complex simple. Let's start monitoring the AI landscape. And yes, we use proper ISO 8601 dates here - because we're scientists, not barbarians.
                        </div>
                        <button class="btn-primary" onclick="dashboard.triggerResearch()">üöÄ Start Research</button>
                    </div>
                `;
            }

            showSupabaseError() {
                document.getElementById('model-grid').innerHTML = `
                    <div class="empty-state error-bg">
                        <h3>üõ∏ Supabase Connection Required</h3>
                        <p>KHAOS-Researcher is a cloud-native system that requires database connectivity.</p>
                        <p>Please ensure Supabase is properly configured.</p>
                        <div class="tars-insight">
                            Cloud-native architecture eliminates complexity. One database, one truth. No fallbacks, no confusion.
                        </div>
                    </div>
                `;
            }

        }

        // Helper functions for exact number display
        function getExactEcosystemCount() {
            // Multiple strategies to get the exact count
            
            // Strategy 1: From ecosystem-ocean model metadata
            const ecosystemModel = dashboard.currentModels?.find(m => m.id === 'ecosystem-ocean');
            if (ecosystemModel?.metadata?.totalModels) {
                return ecosystemModel.metadata.totalModels;
            }
            
            // Strategy 2: From modelData metadata
            if (dashboard.modelData?.metadata?.ecosystemTotal) {
                return dashboard.modelData.metadata.ecosystemTotal;
            }
            
            // Strategy 3: Look for any model with totalModels in metadata
            for (const model of (dashboard.currentModels || [])) {
                if (model.metadata?.totalModels && model.metadata.totalModels > 1000000) {
                    return model.metadata.totalModels;
                }
            }
            
            // Fallback: Return null to indicate we need to fetch
            return null;
        }

        function getEcosystemTimestamp() {
            // Get timestamp of when the ecosystem was last scraped
            const ecosystemModel = dashboard.currentModels?.find(m => m.id === 'ecosystem-ocean');
            if (ecosystemModel?.metadata?.lastScraped) {
                return new Date(ecosystemModel.metadata.lastScraped);
            }
            
            // Fallback to last update time
            if (dashboard.modelData?.metadata?.lastUpdate) {
                return new Date(dashboard.modelData.metadata.lastUpdate);
            }
            
            return new Date(); // Current time as fallback
        }

        function formatExactNumber(number) {
            if (!number || isNaN(number)) return 'Loading...';
            
            // European formatting: 1.865.321 (dots for thousands)
            return number.toLocaleString('de-DE');
        }

        function formatTimestamp(date) {
            if (!date) return 'Unknown';
            
            // Format: 2025-07-10 8:53
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            
            return `${year}-${month}-${day} ${hours}:${minutes}`;
        }

        function updateAllEcosystemReferences(exactCount) {
            if (!exactCount) return;
            
            // Update all text references to ecosystem total
            const ecosystemTextElements = [
                'ecosystem-total-text',
                'ecosystem-count-display',
                'ecosystem-live-count'
            ];
            
            ecosystemTextElements.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.textContent = formatExactNumber(exactCount);
                }
            });
            
            // Update narrative text with exact number
            const narrativeText = document.querySelector('.detail-text');
            if (narrativeText && narrativeText.textContent.includes('HuggingFace hosts')) {
                const curatedCount = dashboard.currentModels ? dashboard.currentModels.filter(m => m.id !== 'ecosystem-ocean').length : 165;
                narrativeText.textContent = `HuggingFace hosts ${formatExactNumber(exactCount)} models, we curate ${curatedCount}+ enterprise-grade`;
            }
        }

        // Function to check if we need to refresh ecosystem data
        function checkEcosystemDataFreshness() {
            const exactCount = getExactEcosystemCount();
            const timestamp = getEcosystemTimestamp();
            
            if (!exactCount) {
                console.log('‚ö†Ô∏è No exact ecosystem count available - triggering research');
                // Could trigger a research update here
                return false;
            }
            
            // Check if data is older than 6 hours
            const sixHoursAgo = new Date(Date.now() - 6 * 60 * 60 * 1000);
            if (timestamp && timestamp < sixHoursAgo) {
                console.log('‚ö†Ô∏è Ecosystem data is stale - consider refreshing');
                return false;
            }
            
            console.log(`‚úÖ Ecosystem data is fresh: ${formatExactNumber(exactCount)} (${formatTimestamp(timestamp)})`);
            return true;
        }

        // Debugging function to check what exact data we have
        function debugEcosystemData() {
            console.log('üîç Debugging ecosystem data:');
            console.log('modelData:', dashboard.modelData);
            console.log('currentModels:', dashboard.currentModels);
            
            const ecosystemModel = dashboard.currentModels?.find(m => m.id === 'ecosystem-ocean');
            console.log('ecosystem-ocean model:', ecosystemModel);
            
            if (ecosystemModel) {
                console.log('totalModels in metadata:', ecosystemModel.metadata?.totalModels);
                console.log('lastScraped:', ecosystemModel.metadata?.lastScraped);
            }
            
            console.log('modelData.metadata.ecosystemTotal:', dashboard.modelData?.metadata?.ecosystemTotal);
        }

        // Test function for debugging scraping patterns
        async function testScrapingPattern() {
            console.log('üß™ Testing HuggingFace scraping pattern...');
            
            try {
                const response = await fetch('https://huggingface.co/models');
                const html = await response.text();
                
                console.log('‚úÖ Fetched HTML, length:', html.length);
                
                // Test the primary pattern
                const primaryPattern = /Models\s+(\d{1,3}(?:,\d{3})*)/i;
                const match = html.match(primaryPattern);
                
                if (match) {
                    const count = parseInt(match[1].replace(/,/g, ''));
                    console.log('üéØ FOUND IT!', 'Models', count.toLocaleString());
                    console.log('Raw match:', match[0]);
                } else {
                    console.log('‚ùå Primary pattern failed');
                    
                    // Show what we can find
                    const allNumbers = html.match(/(\d{1,3}(?:,\d{3})*)/g);
                    console.log('All comma-separated numbers found:', allNumbers?.slice(0, 20));
                    
                    // Test if "Models" appears at all
                    const modelsText = html.match(/Models[^a-zA-Z]*(\d[\d,]*)/i);
                    console.log('Models + number pattern:', modelsText);
                }
                
            } catch (error) {
                console.error('Test failed:', error);
            }
        }

        // Make debugging functions available globally
        window.debugEcosystemData = debugEcosystemData;
        window.testScrapingPattern = testScrapingPattern;

        // ===== AI MODEL RELEASE TIMELINE =====
        const timelineData = [
            {date: '2018-06-11', provider: 'OpenAI', family: 'GPT', model: 'GPT-1', type: 'Model release', notes: 'First Generative Pre-trained Transformer paper and model.'},
            {date: '2019-02-01', provider: 'OpenAI', family: 'GPT', model: 'GPT-2 announcement', type: 'Announcement', notes: 'Initial GPT-2 announcement; largest 1.5B model withheld.'},
            {date: '2019-11-05', provider: 'OpenAI', family: 'GPT', model: 'GPT-2 1.5B', type: 'Model release', notes: 'Full GPT-2 1.5B model released.'},
            {date: '2020-06-11', provider: 'OpenAI', family: 'GPT', model: 'GPT-3 API beta', type: 'Model release', notes: 'GPT-3 announced and made available via API beta.'},
            {date: '2022-11-30', provider: 'OpenAI', family: 'ChatGPT', model: 'ChatGPT launch', type: 'Product launch', notes: 'Public launch of ChatGPT based on GPT-3.5.'},
            {date: '2023-03-14', provider: 'OpenAI', family: 'GPT', model: 'GPT-4', type: 'Model release', notes: 'GPT-4 announced and released for ChatGPT Plus and API.'},
            {date: '2024-05-13', provider: 'OpenAI', family: 'GPT', model: 'GPT-4o', type: 'Model release', notes: 'GPT-4o introduced as new flagship ChatGPT/API model.'},
            {date: '2024-09-12', provider: 'OpenAI', family: 'o1', model: 'o1', type: 'Model release', notes: 'First OpenAI "reasoning" model announced.'},
            {date: '2025-08-05', provider: 'OpenAI', family: 'GPT', model: 'gpt-oss-120b & gpt-oss-20b', type: 'Model release', notes: 'First open-weight GPT-OSS models released.'},
            {date: '2025-08-07', provider: 'OpenAI', family: 'GPT', model: 'GPT-5', type: 'Model release', notes: 'GPT-5 announced as next frontier model in ChatGPT lineup.'},
            {date: '2023-03-21', provider: 'Google', family: 'Gemini', model: 'Bard launch (PaLM-based)', type: 'Product launch', notes: 'Google Bard experimental chatbot launched (pre-Gemini).'},
            {date: '2023-12-06', provider: 'Google', family: 'Gemini', model: 'Gemini 1.0 (Ultra/Pro/Nano)', type: 'Model release', notes: 'Initial Gemini 1.0 family announced.'},
            {date: '2024-02-08', provider: 'Google', family: 'Gemini', model: 'Gemini Advanced (Ultra 1.0)', type: 'Product launch', notes: 'Consumer launch of Gemini Advanced based on Gemini Ultra 1.0.'},
            {date: '2024-02-15', provider: 'Google', family: 'Gemini', model: 'Gemini 1.5 Pro & 1.5 Flash', type: 'Model release', notes: 'High-context Gemini 1.5 models announced and rolled out.'},
            {date: '2025-03-25', provider: 'Google', family: 'Gemini', model: 'Gemini 2.5 Pro Experimental', type: 'Model release', notes: 'Experimental Gemini 2.5 Pro released as most capable model.'},
            {date: '2025-06-17', provider: 'Google', family: 'Gemini', model: 'Gemini 2.5 Pro/Flash/Flash-Lite', type: 'Model release', notes: 'Gemini 2.5 models become standard stable API models.'},
            {date: '2025-11-18', provider: 'Google', family: 'Gemini', model: 'Gemini 3 family', type: 'Model release', notes: 'Next-generation Gemini 3 line announced/rolled out.'},
            {date: '2023-03-01', provider: 'Anthropic', family: 'Claude', model: 'Claude 1 early access', type: 'Model release', notes: 'Claude 1 available in early trials via partners.'},
            {date: '2023-03-14', provider: 'Anthropic', family: 'Claude', model: 'Claude 1 launch', type: 'Product launch', notes: 'Claude 1 officially introduced as Anthropic assistant.'},
            {date: '2024-03-13', provider: 'Anthropic', family: 'Claude', model: 'Claude 3 (Haiku/Sonnet/Opus)', type: 'Model release', notes: 'Claude 3 family announced as successor to Claude 2.x.'},
            {date: '2024-06-01', provider: 'Anthropic', family: 'Claude', model: 'Claude 3 general rollout', type: 'Product launch', notes: 'Claude 3 models broadly available via app and API.'},
            {date: '2025-05-22', provider: 'Anthropic', family: 'Claude', model: 'Claude 4 (Opus 4)', type: 'Model release', notes: 'Claude 4 announced with improved coding and agent skills.'},
            {date: '2025-11-20', provider: 'Anthropic', family: 'Claude', model: 'Claude 4.5 variants', type: 'Model release', notes: 'Updated Claude 4.x variants released in late 2025 wave.'},
            {date: '2023-11-01', provider: 'xAI', family: 'Grok', model: 'Grok-1 early access', type: 'Product launch', notes: 'First Grok chatbot released to select X Premium users.'},
            {date: '2024-05-01', provider: 'xAI', family: 'Grok', model: 'Grok-1.5', type: 'Model release', notes: 'Grok-1.5 launched with improved reasoning and 128k context.'},
            {date: '2024-08-01', provider: 'xAI', family: 'Grok', model: 'Grok-2 & Grok-2 Mini', type: 'Model release', notes: 'Second-generation Grok family with better reasoning and images.'},
            {date: '2025-02-01', provider: 'xAI', family: 'Grok', model: 'Grok-3 & Grok-3 Mini', type: 'Model release', notes: 'Third-generation Grok models including "Think" mode.'},
            {date: '2025-07-09', provider: 'xAI', family: 'Grok', model: 'Grok-4 & Grok-4 Heavy', type: 'Model release', notes: 'New flagship Grok 4 models with tools and real-time search.'},
            {date: '2025-08-10', provider: 'xAI', family: 'Grok', model: 'Code Fast 1 and others', type: 'Model release', notes: 'Specialized Grok models including coding-focused variants.'},
            {date: '2025-09-01', provider: 'xAI', family: 'Grok', model: 'Grok-4 Fast', type: 'Model release', notes: 'Higher-throughput Grok 4 Fast released.'},
            {date: '2025-11-17', provider: 'xAI', family: 'Grok', model: 'Grok-4.1 / 4.1 Fast / 4.1 Thinking', type: 'Model release', notes: 'Latest Grok 4.1 generation focused on reasoning and multimodality.'}
        ];

        class AITimeline {
            constructor(containerId, data) {
                this.container = document.getElementById(containerId);
                this.data = data;
                this.filteredData = data;
                this.activeCard = null;
                this.pinnedCard = null;

                // Provider colors
                this.providerColors = {
                    'OpenAI': '#10A37F',
                    'Google': '#4285F4',
                    'Anthropic': '#D97757',
                    'xAI': '#000000'
                };

                // Setup filters
                this.setupFilters();

                // Render timeline
                this.render();
            }

            setupFilters() {
                const providerFilter = document.getElementById('timeline-provider-filter');
                const yearFilter = document.getElementById('timeline-year-filter');

                if (providerFilter) {
                    providerFilter.addEventListener('change', () => this.applyFilters());
                }

                if (yearFilter) {
                    yearFilter.addEventListener('change', () => this.applyFilters());
                }
            }

            applyFilters() {
                const providerFilter = document.getElementById('timeline-provider-filter').value;
                const yearFilter = document.getElementById('timeline-year-filter').value;

                this.filteredData = this.data.filter(event => {
                    const matchesProvider = !providerFilter || event.provider === providerFilter;
                    const matchesYear = !yearFilter || event.date.startsWith(yearFilter);
                    return matchesProvider && matchesYear;
                });

                this.render();
            }

            render() {
                if (!this.container) return;

                // Clear container
                this.container.innerHTML = '';

                // Group events by year
                const eventsByYear = {};
                this.filteredData.forEach(event => {
                    const year = event.date.substring(0, 4);
                    if (!eventsByYear[year]) {
                        eventsByYear[year] = [];
                    }
                    eventsByYear[year].push(event);
                });

                // Get sorted years
                const years = Object.keys(eventsByYear).sort();

                if (years.length === 0) {
                    this.container.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">No events found matching your filters.</div>';
                    return;
                }

                // Calculate timeline dimensions
                const yearHeight = 80;
                const totalHeight = years.length * yearHeight;

                // Render each year
                years.forEach((year, yearIndex) => {
                    const yearTop = yearIndex * yearHeight;

                    // Year marker
                    const yearMarker = document.createElement('div');
                    yearMarker.className = 'timeline-year-marker';
                    yearMarker.style.top = `${yearTop + 25}px`;
                    yearMarker.textContent = year;
                    this.container.appendChild(yearMarker);

                    // Swimlane
                    const swimlane = document.createElement('div');
                    swimlane.className = 'timeline-swimlane';
                    swimlane.style.top = `${yearTop}px`;
                    swimlane.style.height = `${yearHeight}px`;
                    swimlane.style.position = 'absolute';
                    swimlane.style.width = '100%';

                    // Year line
                    const yearLine = document.createElement('div');
                    yearLine.className = 'timeline-year-line';
                    swimlane.appendChild(yearLine);

                    // Calculate date range for this year
                    const yearStart = new Date(`${year}-01-01`);
                    const yearEnd = new Date(`${year}-12-31`);
                    const yearDuration = yearEnd - yearStart;

                    // Render events for this year
                    eventsByYear[year].forEach((event, eventIndex) => {
                        const eventDate = new Date(event.date);
                        const dayOfYear = (eventDate - yearStart) / yearDuration;

                        // Calculate position (left margin 80px for year label, then distribute across remaining width)
                        const leftPos = 80 + (dayOfYear * (this.container.offsetWidth - 100));

                        // Vertical position - distribute events in the year space
                        const verticalOffset = 20 + (eventIndex % 3) * 15; // Stagger events

                        // Create event node
                        const eventNode = document.createElement('div');
                        eventNode.className = 'timeline-event-node';
                        eventNode.style.left = `${leftPos}px`;
                        eventNode.style.top = `${verticalOffset}px`;

                        // Create node dot
                        const nodeDot = document.createElement('div');
                        nodeDot.className = `node-dot provider-${event.provider.toLowerCase().replace(' ', '')}`;

                        // Set size based on event type
                        let dotSize = 14;
                        if (event.type === 'Product launch') {
                            dotSize = 16;
                            nodeDot.classList.add('product-launch');
                        } else if (event.type === 'Announcement') {
                            dotSize = 12;
                            nodeDot.classList.add('announcement');
                        } else {
                            nodeDot.classList.add('model-release');
                        }

                        nodeDot.style.width = `${dotSize}px`;
                        nodeDot.style.height = `${dotSize}px`;
                        eventNode.appendChild(nodeDot);

                        // Add hover and click handlers
                        eventNode.addEventListener('mouseenter', (e) => this.showEventCard(event, e));
                        eventNode.addEventListener('mouseleave', (e) => this.hideEventCard(e));
                        eventNode.addEventListener('click', (e) => this.togglePinCard(event, e));

                        swimlane.appendChild(eventNode);
                    });

                    this.container.appendChild(swimlane);
                });

                // Set container height
                this.container.style.minHeight = `${totalHeight}px`;
            }

            showEventCard(event, mouseEvent) {
                // Don't show hover card if a card is pinned
                if (this.pinnedCard) return;

                // Remove any existing hover cards
                const existingCard = document.querySelector('.timeline-event-card:not(.pinned)');
                if (existingCard) {
                    existingCard.remove();
                }

                // Create event card
                const card = this.createEventCard(event);
                card.classList.add('show');

                // Position card near the node
                const rect = mouseEvent.currentTarget.getBoundingClientRect();
                const containerRect = this.container.getBoundingClientRect();

                card.style.left = `${rect.left - containerRect.left + 20}px`;
                card.style.top = `${rect.top - containerRect.top - 20}px`;

                this.container.appendChild(card);
                this.activeCard = card;

                // Add node active state
                mouseEvent.currentTarget.classList.add('active');
            }

            hideEventCard(mouseEvent) {
                // Don't hide if pinned
                if (this.pinnedCard) return;

                // Remove active state
                mouseEvent.currentTarget.classList.remove('active');

                // Hide card with delay
                setTimeout(() => {
                    if (this.activeCard && !this.pinnedCard) {
                        this.activeCard.classList.remove('show');
                        setTimeout(() => {
                            if (this.activeCard && !this.pinnedCard) {
                                this.activeCard.remove();
                                this.activeCard = null;
                            }
                        }, 300);
                    }
                }, 100);
            }

            togglePinCard(event, mouseEvent) {
                mouseEvent.stopPropagation();

                // If there's a pinned card, unpin it
                if (this.pinnedCard) {
                    this.pinnedCard.remove();
                    this.pinnedCard = null;
                    // Remove all active states
                    document.querySelectorAll('.timeline-event-node.active').forEach(node => {
                        node.classList.remove('active');
                    });
                    return;
                }

                // Remove any hover cards
                if (this.activeCard) {
                    this.activeCard.remove();
                    this.activeCard = null;
                }

                // Create pinned card
                const card = this.createEventCard(event, true);
                card.classList.add('show', 'pinned');

                // Position card
                const rect = mouseEvent.currentTarget.getBoundingClientRect();
                const containerRect = this.container.getBoundingClientRect();

                card.style.left = `${rect.left - containerRect.left + 20}px`;
                card.style.top = `${rect.top - containerRect.top - 20}px`;

                this.container.appendChild(card);
                this.pinnedCard = card;

                // Add active state
                mouseEvent.currentTarget.classList.add('active');
            }

            createEventCard(event, pinned = false) {
                const card = document.createElement('div');
                card.className = 'timeline-event-card';

                const providerClass = event.provider.toLowerCase().replace(' ', '');

                card.innerHTML = `
                    <div class="event-card-header">
                        <div class="event-card-title">${event.model}</div>
                        ${pinned ? '<button class="event-card-close" onclick="timeline.unpinCard()">√ó</button>' : ''}
                    </div>
                    <div class="event-card-body">
                        <div class="event-card-meta">
                            <div class="event-card-meta-item">
                                <span class="event-card-label">Date:</span>
                                <span class="event-card-value">${this.formatDate(event.date)}</span>
                            </div>
                            <div class="event-card-meta-item">
                                <span class="event-card-label">Provider:</span>
                                <span class="event-card-provider ${providerClass}">${event.provider}</span>
                            </div>
                            <div class="event-card-meta-item">
                                <span class="event-card-label">Family:</span>
                                <span class="event-card-value">${event.family}</span>
                            </div>
                            <div class="event-card-meta-item">
                                <span class="event-card-label">Type:</span>
                                <span class="event-card-type">${event.type}</span>
                            </div>
                        </div>
                        ${event.notes ? `<div class="event-card-notes">${event.notes}</div>` : ''}
                    </div>
                `;

                return card;
            }

            unpinCard() {
                if (this.pinnedCard) {
                    this.pinnedCard.remove();
                    this.pinnedCard = null;
                    // Remove all active states
                    document.querySelectorAll('.timeline-event-node.active').forEach(node => {
                        node.classList.remove('active');
                    });
                }
            }

            formatDate(dateStr) {
                const date = new Date(dateStr);
                const options = { year: 'numeric', month: 'long', day: 'numeric' };
                return date.toLocaleDateString('en-US', options);
            }
        }

        // Initialize cloud dashboard
        const dashboard = new CloudDashboard();
        let timeline; // Global timeline instance

        window.addEventListener('DOMContentLoaded', () => {
            dashboard.init();

            // Initialize rate limiting
            updateResearchButton();

            // Update button state every minute
            setInterval(updateResearchButton, 60000);

            // Initialize AI Timeline
            setTimeout(() => {
                timeline = new AITimeline('timeline-container', timelineData);
                window.timeline = timeline; // Make accessible for close button
            }, 500);
        });
    </script>
</body>
</html>