<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KHAOS AI Model Intelligence Dashboard</title>
    
    <!-- Favicon links -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- Strategic Dashboard Header - Executive Level -->
    <div class="strategic-dashboard-header">
        <!-- Command Center Intelligence -->
        <div class="command-center-section">
            <div class="section-header">
                <h2>üéØ AI Intelligence Command Center</h2>
                <div class="live-indicator">
                    <span class="pulse-dot"></span>
                    <span>Live Monitoring</span>
                </div>
            </div>
            
            <div class="command-metrics-grid">
                <div class="metric-item">
                    <div class="metric-icon">üìä</div>
                    <div class="metric-content">
                        <div class="metric-label">System Status</div>
                        <div class="metric-value" id="system-status">
                            <span class="status-indicator operational"></span>
                            Operational
                        </div>
                    </div>
                </div>
                
                <div class="metric-item">
                    <div class="metric-icon">üîÑ</div>
                    <div class="metric-content">
                        <div class="metric-label">Research Cycle</div>
                        <div class="metric-value" id="research-status">
                            <span class="status-indicator active"></span>
                            <span id="last-research-time">1h ago</span>
                        </div>
                    </div>
                </div>
                
                <div class="metric-item">
                    <div class="metric-icon">‚è±Ô∏è</div>
                    <div class="metric-content">
                        <div class="metric-label">Next Auto-Research</div>
                        <div class="metric-value" id="next-research-time">
                            <span class="countdown-timer" id="countdown">4h 34m</span>
                        </div>
                    </div>
                </div>
                
                <div class="metric-item">
                    <div class="metric-icon">üóÑÔ∏è</div>
                    <div class="metric-content">
                        <div class="metric-label">Database</div>
                        <div class="metric-value" id="database-connection-status">
                            <span class="status-indicator connected"></span>
                            Supabase Connected
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="research-controls">
                <button id="research-btn" class="btn-primary strategic-btn" onclick="dashboard.triggerResearch()">üöÄ Trigger Research</button>
                <div id="progress-container" class="progress-container" style="display: none;">
                    <div class="progress-bar">
                        <div id="progress-fill" class="progress-fill"></div>
                    </div>
                    <div id="progress-text" class="progress-text">Starting research...</div>
                </div>
            </div>
            
            <div class="research-progress">
                <div class="progress-label">Research Cycle Progress</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="research-progress"></div>
                </div>
            </div>
        </div>
        
        <!-- Ecosystem Intelligence Briefing -->
        <div class="ecosystem-intelligence-section">
            <div class="section-header">
                <h2>üåä AI Ecosystem Intelligence</h2>
                <div class="live-indicator">
                    <span class="pulse-dot growth"></span>
                    <span>Live Data</span>
                </div>
            </div>
            
            <div class="intelligence-metrics-grid">
                <div class="intel-card primary">
                    <div class="intel-number" id="ecosystem-total-strategic">1.89M+</div>
                    <div class="intel-label">Total AI Models</div>
                    <div class="intel-sublabel">in Ecosystem</div>
                </div>
                
                <div class="intel-card secondary">
                    <div class="intel-number" id="growth-velocity">+125K</div>
                    <div class="intel-label">Monthly Growth</div>
                    <div class="intel-sublabel">models/month</div>
                </div>
                
                <div class="intel-card tertiary">
                    <div class="intel-number" id="curated-models-strategic">165+</div>
                    <div class="intel-label">Curated Models</div>
                    <div class="intel-sublabel">enterprise-grade</div>
                </div>
            </div>
            
            <div class="intelligence-narrative">
                <div class="narrative-highlight">
                    <strong>Intelligence Focus:</strong> We track the largest repository of AI models, 
                    showing <strong>15.6x growth in 30 months</strong> - the democratization of AI in real-time.
                </div>
                <div class="narrative-details">
                    <div class="detail-item">
                        <span class="detail-label">Scale:</span>
                        <span class="detail-value">HuggingFace hosts 1.89M+ models, we curate 165+ enterprise-grade</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">Velocity:</span>
                        <span class="detail-value">Exponential growth phase - 125K new models monthly</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">Impact:</span>
                        <span class="detail-value">AI democratization from research labs to global accessibility</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Ecosystem Context Section -->
    <div class="ecosystem-context khaos-card">
        <div class="context-header">
            <h2>üåä AI Model Ecosystem Intelligence</h2>
            <div class="ecosystem-badge">Live Data</div>
        </div>
        
        <div class="ecosystem-stats">
            <div class="stat-highlight">
                <div class="big-number" id="ecosystem-total">1.800.000+</div>
                <div class="stat-label">Total AI Models in Ecosystem</div>
            </div>
            
            <div class="curation-info">
                <div class="curation-stat">
                    <span class="curation-number" id="curated-count">~100</span>
                    <span class="curation-label">Curated Enterprise Models Shown</span>
                </div>
                <div class="curation-note">
                    <strong>Intelligence Focus:</strong> We show a carefully curated subset of high-quality models 
                    from major providers, while tracking the full ecosystem scale. 
                    <span class="data-source">Source: HuggingFace Hub</span>
                </div>
                
                <div class="ecosystem-context-grid">
                    <div class="context-item">
                        <strong>Scale:</strong> While enterprise providers release dozens of curated models, 
                        the community has democratized AI with tens of thousands of open contributions.
                    </div>
                    <div class="context-item">
                        <strong>Impact:</strong> This represents the largest repository of accessible AI models, 
                        from research experiments to production-ready solutions.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="charts-container">
        <div class="chart-section khaos-card">
            <h2>üìä Provider Distribution</h2>
            <div id="provider-chart"></div>
        </div>
        
        <div class="chart-section khaos-card">
            <h2>üìà AI Democratization Timeline</h2>
            <p style="color: #666; margin-bottom: 15px;">The explosive growth of AI model ecosystem - 15.6x growth in 30 months</p>
            <div id="timeline-chart"></div>
            
            <!-- Timeline insights -->
            <div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                <div style="display: flex; gap: 20px; font-size: 0.9em; color: #666;">
                    <div><strong>Foundation Era</strong>: 2023 (121K ‚Üí 420K)</div>
                    <div><strong>Acceleration</strong>: 2024 (420K ‚Üí 1.05M)</div>
                    <div><strong>Exponential</strong>: 2025 (1.05M ‚Üí 1.89M+)</div>
                </div>
            </div>
        </div>
    </div>


    <div class="models-section khaos-card">
        <h2>üóÑÔ∏è All Models</h2>
        <div class="filter-controls">
            <select id="provider-filter">
                <option value="">All Providers</option>
            </select>
            <input type="text" id="search-filter" placeholder="üîç Search models...">
        </div>
        <div id="model-grid"></div>
        
        <div class="date-legend">
            <h3>üìÖ Release Date Sources</h3>
            <div class="legend-grid">
                <div class="legend-item">
                    <span class="legend-icon">üì§</span>
                    <span class="legend-text">HuggingFace upload date</span>
                </div>
                <div class="legend-item">
                    <span class="legend-icon">üìã</span>
                    <span class="legend-text">Known release date</span>
                </div>
                <div class="legend-item">
                    <span class="legend-icon">üè¢</span>
                    <span class="legend-text">Provider estimate</span>
                </div>
                <div class="legend-item">
                    <span class="legend-icon">üåä</span>
                    <span class="legend-text">Ecosystem snapshot</span>
                </div>
                <div class="legend-item">
                    <span class="legend-icon">üìÖ</span>
                    <span class="legend-text">Last modified</span>
                </div>
                <div class="legend-item">
                    <span class="legend-icon">üîÑ</span>
                    <span class="legend-text">Updated date</span>
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        <p>Ceterum censeo: SBaaS‚Ñ¢ ‚Äì Scaling Business as a Service is the way forward to Accelerate Growth! üöÄ</p>
        <p>Cost of Delay Estimator (CoDE) for postponing decisions -- you don't have to act now, but it's good to know the price and then think it through thoroughly. üëâ <a href="https://cotoaga.net/code/" target="_blank">CoDE üßÆ</a></p>
    </div>

    <script>
        // Cloud-ready dashboard JavaScript
        class CloudDashboard {
            constructor() {
                this.apiBase = window.location.origin;
                this.modelData = null;
                this.lastUpdate = null;
                this.currentModels = [];
            }

            formatModelDate(created, metadata = null) {
                // Handle various timestamp formats
                if (!created || created === null || created === undefined) {
                    return this.getDateSourceLabel('unknown', metadata);
                }
                
                let timestamp;
                if (typeof created === 'string') {
                    timestamp = new Date(created);
                } else if (typeof created === 'number') {
                    // Handle both seconds and milliseconds timestamps
                    timestamp = created > 1000000000000 
                        ? new Date(created)           // Already milliseconds
                        : new Date(created * 1000);   // Convert seconds to milliseconds
                } else {
                    return this.getDateSourceLabel('invalid', metadata);
                }
                
                // Check if date is valid
                if (isNaN(timestamp.getTime())) {
                    return this.getDateSourceLabel('invalid', metadata);
                }
                
                // Format date: YYYY-MM-DD
                const dateStr = timestamp.getFullYear() + '-' + 
                       String(timestamp.getMonth() + 1).padStart(2, '0') + '-' + 
                       String(timestamp.getDate()).padStart(2, '0');
                
                return this.getDateSourceLabel(dateStr, metadata);
            }
            
            getDateSourceLabel(dateStr, metadata) {
                if (!metadata || !metadata.dateSource) {
                    return dateStr === 'unknown' ? '‚ùì Unknown release date' : 
                           dateStr === 'invalid' ? '‚ùì Invalid date' : 'üìÖ ' + dateStr;
                }
                
                const sourceLabels = {
                    'last-modified': 'üìÖ ',
                    'upload-date': 'üì§ ',
                    'updated': 'üîÑ ',
                    'ecosystem-snapshot': 'üåä ',
                    'rawDate-metadata': 'üì§ ',
                    'known-date': 'üìã ',
                    'provider-fallback': 'üè¢ ',
                    'unknown': '‚ùì '
                };
                
                const icon = sourceLabels[metadata.dateSource] || 'üì§ ';
                
                if (dateStr === 'unknown') {
                    return '‚ùì Unknown release date';
                } else if (dateStr === 'invalid') {
                    return '‚ùì Invalid date';
                } else {
                    return icon + dateStr;
                }
            }

            async loadData() {
                try {
                    const response = await fetch(`${this.apiBase}/api/data`);
                    const result = await response.json();
                    
                    if (result.success) {
                        this.modelData = result.data;
                        this.currentModels = Object.values(this.modelData.models || {});
                        this.lastUpdate = new Date();
                        return true;
                    } else {
                        throw new Error(result.error);
                    }
                } catch (error) {
                    console.error('Failed to load data:', error);
                    this.showSupabaseError();
                    return false;
                }
            }

            async triggerResearch() {
                try {
                    // Show progress bar
                    this.showProgress('Starting research...', 10);
                    
                    // Disable button
                    const btn = document.getElementById('research-btn');
                    btn.disabled = true;
                    btn.textContent = 'üîÑ Researching...';
                    
                    this.showProgress('Gathering AI model data...', 30);
                    
                    const response = await fetch(`${this.apiBase}/api/research`, {
                        method: 'POST'
                    });
                    
                    this.showProgress('Processing results...', 70);
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.showProgress(`Found ${result.discoveries} discoveries!`, 90);
                        
                        // Wait and reload data
                        setTimeout(async () => {
                            this.showProgress('Updating dashboard...', 95);
                            const loaded = await this.loadData();
                            if (loaded) {
                                this.renderAll();
                                this.showProgress('Research complete!', 100);
                                setTimeout(() => this.hideProgress(), 1000);
                            }
                        }, 1500);
                    } else {
                        throw new Error(result.error);
                    }
                } catch (error) {
                    console.error('Research failed:', error);
                    this.hideProgress();
                    alert('Research failed: ' + error.message);
                } finally {
                    // Re-enable button
                    setTimeout(() => {
                        const btn = document.getElementById('research-btn');
                        btn.disabled = false;
                        btn.textContent = 'üöÄ Trigger Research';
                    }, 3000);
                }
            }
            
            showProgress(text, percentage) {
                const container = document.getElementById('progress-container');
                const fill = document.getElementById('progress-fill');
                const textEl = document.getElementById('progress-text');
                
                container.style.display = 'block';
                fill.style.width = percentage + '%';
                textEl.textContent = text;
            }
            
            hideProgress() {
                const container = document.getElementById('progress-container');
                container.style.display = 'none';
            }


            updateStatus(status, text) {
                // Status updates now handled in updateSystemStatus
                // Removed console logging for cleaner output
            }

            async init() {
                const loaded = await this.loadData();
                if (loaded) {
                    this.renderAll();
                } else {
                    this.showEmptyState();
                }

                // Set up auto-refresh every 5 minutes
                setInterval(() => {
                    this.loadData().then(loaded => {
                        if (loaded) this.renderAll();
                    });
                }, 5 * 60 * 1000);

                // Update progress bar every minute
                setInterval(() => {
                    this.updateResearchProgress();
                }, 60 * 1000);
            }

            renderAll() {
                if (!this.modelData) return;
                
                // Convert Supabase format to dashboard format
                this.currentModels = Object.values(this.modelData.models || {});
                
                this.updateStats();
                this.updateEcosystemMetrics(); // NEW: Add ecosystem metrics
                this.updateResearchProgress(); // NEW: Update research progress
                this.renderProviderChart();
                this.renderTimelineChart();
                this.updateFilters(); // This must come before renderModelGrid
                this.renderModelGrid();
            }

            updateStats() {
                const totalModels = this.currentModels.length;
                const providers = new Set(this.currentModels.map(m => m.provider)).size;
                
                // Try multiple metadata timestamp fields
                const lastUpdate = this.modelData.metadata?.lastUpdate || 
                                 this.modelData.metadata?.timestamp || 
                                 this.modelData.timestamp || 
                                 'Unknown';
                
                // Update consolidated status block (for existing ecosystem context)
                const totalModelsEl = document.getElementById('total-models');
                const totalProvidersEl = document.getElementById('total-providers');
                if (totalModelsEl) totalModelsEl.textContent = totalModels.toLocaleString('de-DE');
                if (totalProvidersEl) totalProvidersEl.textContent = providers;
                
                // Calculate last research time
                if (lastUpdate !== 'Unknown') {
                    const updateDate = new Date(lastUpdate);
                    if (!isNaN(updateDate.getTime())) {
                        const now = new Date();
                        const timeDiff = now - updateDate;
                        const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                        const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
                        
                        let timeAgo;
                        if (hours > 0) {
                            timeAgo = `${hours} hour${hours > 1 ? 's' : ''} ago`;
                        } else if (minutes > 0) {
                            timeAgo = `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
                        } else {
                            timeAgo = 'just now';
                        }
                        
                        // Update old elements if they exist
                        const lastResearchEl = document.getElementById('last-research');
                        if (lastResearchEl) lastResearchEl.textContent = timeAgo;
                        
                        // Update strategic dashboard elements
                        const lastResearchTimeEl = document.getElementById('last-research-time');
                        if (lastResearchTimeEl) lastResearchTimeEl.textContent = timeAgo;
                        
                        // Calculate next auto-research (6 hours cycle)
                        const nextResearch = new Date(updateDate.getTime() + (6 * 60 * 60 * 1000));
                        const nextDiff = nextResearch - now;
                        if (nextDiff > 0) {
                            const nextHours = Math.floor(nextDiff / (1000 * 60 * 60));
                            const nextMinutes = Math.floor((nextDiff % (1000 * 60 * 60)) / (1000 * 60));
                            const nextTimeText = `${nextHours}h ${nextMinutes}m`;
                            
                            // Update old elements if they exist
                            const nextResearchEl = document.getElementById('next-research');
                            if (nextResearchEl) nextResearchEl.textContent = `in ${nextTimeText}`;
                            
                            // Update strategic dashboard countdown
                            const countdownEl = document.getElementById('countdown');
                            if (countdownEl) countdownEl.textContent = nextTimeText;
                        } else {
                            const nextResearchEl = document.getElementById('next-research');
                            if (nextResearchEl) nextResearchEl.textContent = 'due now';
                            
                            const countdownEl = document.getElementById('countdown');
                            if (countdownEl) countdownEl.textContent = 'due now';
                        }
                    } else {
                        const lastResearchEl = document.getElementById('last-research');
                        if (lastResearchEl) lastResearchEl.textContent = 'unknown';
                        
                        const lastResearchTimeEl = document.getElementById('last-research-time');
                        if (lastResearchTimeEl) lastResearchTimeEl.textContent = 'unknown';
                        
                        const nextResearchEl = document.getElementById('next-research');
                        if (nextResearchEl) nextResearchEl.textContent = 'unknown';
                        
                        const countdownEl = document.getElementById('countdown');
                        if (countdownEl) countdownEl.textContent = 'unknown';
                    }
                } else {
                    const lastResearchEl = document.getElementById('last-research');
                    if (lastResearchEl) lastResearchEl.textContent = 'unknown';
                    
                    const lastResearchTimeEl = document.getElementById('last-research-time');
                    if (lastResearchTimeEl) lastResearchTimeEl.textContent = 'unknown';
                    
                    const nextResearchEl = document.getElementById('next-research');
                    if (nextResearchEl) nextResearchEl.textContent = 'unknown';
                    
                    const countdownEl = document.getElementById('countdown');
                    if (countdownEl) countdownEl.textContent = 'unknown';
                }
                
                // Update strategic dashboard
                this.updateStrategicDashboard();
            }

            updateStrategicDashboard() {
                // Update system status
                this.updateSystemStatus();
                
                // Update ecosystem intelligence
                this.updateEcosystemIntelligence();
                
                // Update research progress
                this.updateResearchProgress();
            }

            updateSystemStatus() {
                const statusElement = document.getElementById('system-status');
                const databaseStatusElement = document.getElementById('database-connection-status');
                
                // Update based on actual system state
                if (statusElement) {
                    statusElement.innerHTML = `
                        <span class="status-indicator operational"></span>
                        Operational
                    `;
                }
                
                if (databaseStatusElement) {
                    databaseStatusElement.innerHTML = `
                        <span class="status-indicator connected"></span>
                        Supabase Connected
                    `;
                }
            }

            updateEcosystemIntelligence() {
                // Update with latest timeline data
                const ecosystemTotalStrategic = document.getElementById('ecosystem-total-strategic');
                const growthVelocity = document.getElementById('growth-velocity');
                const curatedModelsStrategic = document.getElementById('curated-models-strategic');
                
                if (ecosystemTotalStrategic) {
                    ecosystemTotalStrategic.textContent = '1.89M+';
                }
                
                if (growthVelocity) {
                    growthVelocity.textContent = '+125K';
                }
                
                if (curatedModelsStrategic) {
                    const currentTotal = this.currentModels?.length || 165;
                    curatedModelsStrategic.textContent = `${currentTotal}+`;
                }
            }

            updateResearchProgress() {
                const progressElement = document.getElementById('research-progress');
                if (!progressElement) return;
                
                // Calculate progress based on time since last research
                const lastUpdate = this.modelData?.metadata?.lastUpdate;
                if (lastUpdate) {
                    const timeSinceUpdate = new Date() - new Date(lastUpdate);
                    const sixHoursMs = 6 * 60 * 60 * 1000;
                    const progress = Math.min((timeSinceUpdate / sixHoursMs) * 100, 100);
                    
                    progressElement.style.width = `${progress}%`;
                } else {
                    // If no data yet, start with 0%
                    progressElement.style.width = '0%';
                }
            }

            updateEcosystemMetrics() {
                if (!this.modelData || !this.modelData.models) return;
                
                // Find ecosystem model
                const ecosystemModel = Object.values(this.modelData.models)
                    .find(model => model.metadata?.type === 'ecosystem-ocean');
                
                if (ecosystemModel && ecosystemModel.metadata.totalModels) {
                    const total = ecosystemModel.metadata.totalModels;
                    document.getElementById('ecosystem-total').textContent = 
                        total >= 1000000 ? `${(total/1000000).toFixed(1)}M+` : `${Math.floor(total/1000)}K+`;
                }
                
                // Count curated models (excluding ecosystem model)
                const curatedCount = Object.values(this.modelData.models)
                    .filter(model => model.metadata?.type !== 'ecosystem-ocean').length;
                
                document.getElementById('curated-count').textContent = `~${curatedCount}`;
            }

            renderProviderChart() {
                // EXCLUDE ecosystem model from provider chart
                const enterpriseModels = this.currentModels.filter(model => 
                    model.metadata?.type !== 'ecosystem-ocean'
                );
                
                const providers = {};
                enterpriseModels.forEach(model => {
                    providers[model.provider] = (providers[model.provider] || 0) + 1;
                });

                const data = Object.entries(providers).map(([name, value]) => ({ name, value }));
                
                // Simple bar chart with D3
                const container = document.getElementById('provider-chart');
                container.innerHTML = '';
                
                const width = 400;
                const height = 200;
                const margin = { top: 20, right: 20, bottom: 40, left: 60 };
                
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                const x = d3.scaleBand()
                    .domain(data.map(d => d.name))
                    .range([margin.left, width - margin.right])
                    .padding(0.1);
                
                const y = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.value)])
                    .range([height - margin.bottom, margin.top]);
                
                svg.selectAll('rect')
                    .data(data)
                    .enter()
                    .append('rect')
                    .attr('class', 'chart-bar')
                    .attr('x', d => x(d.name))
                    .attr('y', d => y(d.value))
                    .attr('width', x.bandwidth())
                    .attr('height', d => y(0) - y(d.value))
                    .attr('fill', '#2F6EBA');
                
                // Add axes
                svg.append('g')
                    .attr('transform', `translate(0,${height - margin.bottom})`)
                    .call(d3.axisBottom(x));
                
                svg.append('g')
                    .attr('transform', `translate(${margin.left},0)`)
                    .call(d3.axisLeft(y));
            }

            renderTimelineChart() {
                const container = document.getElementById('timeline-chart');
                container.innerHTML = '';
                
                // Timeline data with growth phases - AI democratization story
                const timelineData = [
                    // Foundation Era (2023)
                    { date: '2023-01', models: 121000, phase: 'foundation', type: 'historical' },
                    { date: '2023-06', models: 239000, phase: 'foundation', type: 'historical' },
                    { date: '2023-10', models: 371000, phase: 'foundation', type: 'historical' },
                    { date: '2023-12', models: 420000, phase: 'foundation', type: 'interpolated' },
                    
                    // Acceleration Phase (2024)
                    { date: '2024-03', models: 510000, phase: 'acceleration', type: 'interpolated' },
                    { date: '2024-06', models: 645000, phase: 'acceleration', type: 'interpolated' },
                    { date: '2024-09', models: 825000, phase: 'acceleration', type: 'interpolated' },
                    { date: '2024-12', models: 1050000, phase: 'acceleration', type: 'milestone' },
                    
                    // Exponential Era (2025)
                    { date: '2025-01', models: 1140000, phase: 'exponential', type: 'interpolated' },
                    { date: '2025-03', models: 1350000, phase: 'exponential', type: 'interpolated' },
                    { date: '2025-05', models: 1600000, phase: 'exponential', type: 'interpolated' },
                    { date: '2025-07', models: 1890000, phase: 'exponential', type: 'current-estimate' }
                ];

                const width = 600;
                const height = 300;
                const margin = { top: 30, right: 30, bottom: 60, left: 80 };
                
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                // Parse dates and set up scales
                const parseDate = d3.timeParse('%Y-%m');
                timelineData.forEach(d => {
                    d.parsedDate = parseDate(d.date);
                });

                const xScale = d3.scaleTime()
                    .domain(d3.extent(timelineData, d => d.parsedDate))
                    .range([margin.left, width - margin.right]);

                const yScale = d3.scaleLinear()
                    .domain([0, d3.max(timelineData, d => d.models) * 1.1])
                    .range([height - margin.bottom, margin.top]);

                // Growth phases background
                const phases = [
                    { name: 'Foundation Era', start: '2023-01', end: '2023-12', color: '#2F6EBA' },
                    { name: 'Acceleration Phase', start: '2024-01', end: '2024-12', color: '#6EC1E4' },
                    { name: 'Exponential Era', start: '2025-01', end: '2025-07', color: '#66BB6A' }
                ];

                phases.forEach(phase => {
                    const startX = xScale(parseDate(phase.start));
                    const endX = xScale(parseDate(phase.end));
                    
                    svg.append('rect')
                        .attr('x', startX)
                        .attr('y', margin.top)
                        .attr('width', endX - startX)
                        .attr('height', height - margin.top - margin.bottom)
                        .attr('fill', phase.color)
                        .attr('opacity', 0.1);

                    // Phase labels
                    svg.append('text')
                        .attr('x', startX + (endX - startX) / 2)
                        .attr('y', margin.top + 15)
                        .attr('text-anchor', 'middle')
                        .style('font-size', '11px')
                        .style('font-weight', 'bold')
                        .style('fill', phase.color)
                        .text(phase.name);
                });

                // Create line generator
                const line = d3.line()
                    .x(d => xScale(d.parsedDate))
                    .y(d => yScale(d.models))
                    .curve(d3.curveMonotoneX);

                // Add the growth line
                svg.append('path')
                    .datum(timelineData)
                    .attr('fill', 'none')
                    .attr('stroke', '#2F6EBA')
                    .attr('stroke-width', 3)
                    .attr('d', line);

                // Add data points with different styles
                const pointColors = {
                    'historical': '#2F6EBA',
                    'milestone': '#66BB6A',
                    'interpolated': '#6EC1E4',
                    'current-estimate': '#FFA726'
                };

                svg.selectAll('.data-point')
                    .data(timelineData)
                    .enter()
                    .append('circle')
                    .attr('class', 'data-point')
                    .attr('cx', d => xScale(d.parsedDate))
                    .attr('cy', d => yScale(d.models))
                    .attr('r', d => d.type === 'milestone' ? 6 : (d.type === 'historical' ? 5 : 3))
                    .attr('fill', d => pointColors[d.type])
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 2);

                // Add axes
                svg.append('g')
                    .attr('transform', `translate(0,${height - margin.bottom})`)
                    .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat('%Y-%m')));

                svg.append('g')
                    .attr('transform', `translate(${margin.left},0)`)
                    .call(d3.axisLeft(yScale).tickFormat(d => {
                        if (d >= 1000000) return (d / 1000000).toFixed(1) + 'M';
                        if (d >= 1000) return (d / 1000).toFixed(0) + 'K';
                        return d.toString();
                    }));

                // Add axis labels
                svg.append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', 0)
                    .attr('x', 0 - (height / 2))
                    .attr('dy', '1em')
                    .style('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .text('AI Models (HuggingFace)');

                svg.append('text')
                    .attr('transform', `translate(${width / 2}, ${height - 10})`)
                    .style('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .text('Timeline');

                // Add key insights
                const insights = [
                    '15.6x growth in 30 months',
                    'Current: ~125K models/month',
                    'Inflection: Mid-2024'
                ];

                const insightContainer = svg.append('g')
                    .attr('transform', `translate(${width - margin.right - 10}, ${margin.top + 10})`);

                insights.forEach((insight, i) => {
                    insightContainer.append('text')
                        .attr('x', 0)
                        .attr('y', i * 15)
                        .attr('text-anchor', 'end')
                        .style('font-size', '10px')
                        .style('font-weight', 'bold')
                        .style('fill', '#666')
                        .text(insight);
                });

                // Add milestone marker for 1M models
                const millionPoint = timelineData.find(d => d.models >= 1000000);
                if (millionPoint) {
                    svg.append('line')
                        .attr('x1', xScale(millionPoint.parsedDate))
                        .attr('x2', xScale(millionPoint.parsedDate))
                        .attr('y1', yScale(millionPoint.models))
                        .attr('y2', yScale(millionPoint.models) - 20)
                        .attr('stroke', '#66BB6A')
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', '5,5');

                    svg.append('text')
                        .attr('x', xScale(millionPoint.parsedDate))
                        .attr('y', yScale(millionPoint.models) - 25)
                        .attr('text-anchor', 'middle')
                        .style('font-size', '10px')
                        .style('font-weight', 'bold')
                        .style('fill', '#66BB6A')
                        .text('1M Models');
                }
            }

            renderModelGrid() {
                const grid = document.getElementById('model-grid');
                grid.innerHTML = '';
                
                // Filter out the ecosystem model from individual model display
                const displayModels = this.currentModels.filter(model => 
                    model.metadata?.type !== 'ecosystem-ocean'
                );
                
                // Get current filter values
                const providerFilter = document.getElementById('provider-filter').value;
                const searchFilter = document.getElementById('search-filter').value.toLowerCase();
                
                // Filter models based on selections
                let filteredModels = displayModels;
                
                if (providerFilter) {
                    filteredModels = filteredModels.filter(model => model.provider === providerFilter);
                }
                
                if (searchFilter) {
                    filteredModels = filteredModels.filter(model => 
                        model.id.toLowerCase().includes(searchFilter) ||
                        model.provider.toLowerCase().includes(searchFilter) ||
                        (model.capabilities && model.capabilities.some(cap => 
                            cap.toLowerCase().includes(searchFilter)
                        ))
                    );
                }
                
                if (filteredModels.length === 0) {
                    grid.innerHTML = `
                        <div class="empty-state">
                            <h3>üîç No Models Found</h3>
                            <p>Try adjusting your filters or search terms.</p>
                        </div>
                    `;
                    return;
                }
                
                filteredModels.forEach(model => {
                    const card = document.createElement('div');
                    card.className = 'model-card';
                    
                    // Enhanced date formatting with source info
                    const formattedDate = this.formatModelDate(model.created, model.metadata);
                    
                    card.innerHTML = `
                        <h3>${model.id}</h3>
                        <p><strong>Provider:</strong> ${model.provider}</p>
                        <p><strong>Capabilities:</strong> ${(model.capabilities || []).join(', ') || 'None listed'}</p>
                        <p><strong>Released:</strong> ${formattedDate}</p>
                    `;
                    grid.appendChild(card);
                });
            }

            updateFilters() {
                const providerFilter = document.getElementById('provider-filter');
                const providers = [...new Set(this.currentModels.map(m => m.provider))].sort();
                
                // Store current selection
                const currentSelection = providerFilter.value;
                
                providerFilter.innerHTML = '<option value="">All Providers</option>';
                providers.forEach(provider => {
                    const option = document.createElement('option');
                    option.value = provider;
                    option.textContent = provider;
                    if (provider === currentSelection) {
                        option.selected = true;
                    }
                    providerFilter.appendChild(option);
                });
                
                // Add event listeners if not already added
                if (!providerFilter.hasAttribute('data-listener-added')) {
                    providerFilter.addEventListener('change', () => this.renderModelGrid());
                    providerFilter.setAttribute('data-listener-added', 'true');
                }
                
                const searchFilter = document.getElementById('search-filter');
                if (!searchFilter.hasAttribute('data-listener-added')) {
                    searchFilter.addEventListener('input', () => this.renderModelGrid());
                    searchFilter.setAttribute('data-listener-added', 'true');
                }
            }

            showEmptyState() {
                document.getElementById('model-grid').innerHTML = `
                    <div class="empty-state">
                        <h3>üîÑ Initializing KHAOS-Researcher...</h3>
                        <p>Triggering first research cycle...</p>
                        <div class="tars-insight">
                            The beauty of intelligence systems lies not in their complexity, but in their ability to make the complex simple. Let's start monitoring the AI landscape. And yes, we use proper ISO 8601 dates here - because we're scientists, not barbarians.
                        </div>
                        <button class="btn-primary" onclick="dashboard.triggerResearch()">üöÄ Start Research</button>
                    </div>
                `;
            }

            showSupabaseError() {
                document.getElementById('model-grid').innerHTML = `
                    <div class="empty-state error-bg">
                        <h3>üõ∏ Supabase Connection Required</h3>
                        <p>KHAOS-Researcher is a cloud-native system that requires database connectivity.</p>
                        <p>Please ensure Supabase is properly configured.</p>
                        <div class="tars-insight">
                            Cloud-native architecture eliminates complexity. One database, one truth. No fallbacks, no confusion.
                        </div>
                    </div>
                `;
            }

        }

        // Initialize cloud dashboard
        const dashboard = new CloudDashboard();
        window.addEventListener('DOMContentLoaded', () => {
            dashboard.init();
        });
    </script>
</body>
</html>